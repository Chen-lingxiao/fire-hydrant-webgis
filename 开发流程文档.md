# 环境准备
## 前端环境：Node.js + Vue CLI
[Vue 2+3笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/ugegf1g1ou8qqpq0)

搭建 Vue3 项目，管理前端依赖

**<font style="color:#01B2BC;">下载 Node.js、pnpm</font>**

验证安装：打开 cmd / 终端，输入 `node -v` 和 `pnpm -v`，显示版本号

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756198423690-9eb72e24-11f6-48ac-a822-99e819b6e72f.png)

**<font style="color:#01B2BC;">安装 Vue CLI：</font>**

```javascript
pnpm install -g @vue/cli
```

安装完成后输入 `vue -V`（大写 V），显示版本号

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756198504167-875c61a2-12a2-4716-a64b-807d421f7851.png)

## 后端环境：JDK + IntelliJ IDEA + Maven
[JavaSE笔记](https://www.yuque.com/lingxiao-yugup/el7hri/ycts95273pst8guq)

[MyBatisPlus+Spring Boot+Maven笔记](https://www.yuque.com/lingxiao-yugup/el7hri/qeg9zw0ufkh0hsqu)

开发 Spring Boot 后端，操作数据库

**<font style="color:#01B2BC;">安装 JDK </font>**  
终端输入 `java -version`

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756198536526-d3143922-7414-4bc0-8c2c-b1d5bba45c1e.png)

**<font style="color:#01B2BC;">安装 IntelliJ IDEA</font>**

略

Maven 用 IDEA 自带的，避免版本冲突，后续统一通过`pom.xml`管理依赖

## 数据库环境：PostgreSQL + PostGIS
存储 GeoJSON 数据、数据表

步骤略，查看 [PostGIS笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/kmefkvzxzp9aopb1)、 [QGIS笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/utpray7rgeq34yae)

## 地图服务：GeoServer（后续扩展用，先安装备用）
发布 PostGIS 中的消防栓图层，供前端地图加载

步骤略，查看[GeoServer笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/cprzxo2fe544d9v3)、[Tomcat笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/anos5eau9z79hpc6)

# 基础项目创建
## 项目架构
### 创建项目
```bash
pnpm create vue
```

`fire-hydrant-frontend`<font style="color:rgba(0, 0, 0, 0.85);">（项目名：消防栓-前端）；</font>

```bash
◇  请输入项目名称：
│  fire-hydrant-frontend
│
◆  请选择要包含的功能： (↑/↓ 切换，空格选择，a 全选，回车确认)
│  ◼ TypeScript
│  ◻ JSX 支持
│  ◼ Router（单页面应用开发）
│  ◼ Pinia（状态管理）
│  ◻ Vitest（单元测试）
│  ◻ 端到端测试
│  ◼ ESLint（错误预防）
│  ◼ Prettier（代码格式化）

PS H:\Project\fire-hydrant-webgis> pnpm create vue
┌  Vue.js - The Progressive JavaScript Framework
│
◇  请输入项目名称：
│  fire-hydrant-frontend
│
◇  请选择要包含的功能： (↑/↓ 切换，空格选择，a 全选，回车确认)
│  TypeScript, Router（单页面应用开发）, Pinia（状态管理）, ESLint（错误预防）, Prettier（代码格式化）
│
◇  选择要包含的试验特性： (↑/↓ 切换，空格选择，a 全选，回车确认)
│  none
│
◇  跳过所有示例代码，创建一个空白的 Vue 项目？
│  Yes

正在初始化项目 H:\Project\fire-hydrant-webgis\fire-hydrant-frontend...
│
└  项目初始化完成，可执行以下命令：

   cd fire-hydrant-frontend
   pnpm install
   pnpm format
   pnpm dev

| 可选：使用以下命令在项目目录中初始化 Git：

   git init && git add -A && git commit -m "initial commit
```

### 安装依赖
```bash
pnpm install
```

**<font style="color:#01B2BC;">Element Plus（PC端UI组件库）</font>**

**<font style="color:rgb(51, 51, 51);">官方文档：</font>**[<font style="color:rgb(65, 131, 196);">https://element-plus.org/zh-CN/</font>](https://element-plus.org/zh-CN/)

```bash
pnpm add element-plus
```

**<font style="color:#DF2A3F;">解决 ElMessage 报错问题</font>**

`eslint.config.js` 中声明全局变量名

```javascript
{
    languageOptions: {
      globals: {
        ...globals.browser,
        ElMessage: 'readonly',
        ElMessageBox: 'readonly',
        ElLoading: 'readonly'
      }
    }
  },
```

或者`env.d.ts`import type 声明仅导入类型

```javascript
/// <reference types="vite/client" />
// 用 import type 声明仅导入类型，并忽略未使用提示
import type { ElMessage } from 'element-plus' // eslint-disable-line @typescript-eslint/no-unused-vars

// 声明全局变量 ElMessage
declare global {
  const ElMessage: typeof ElMessage
  ......
}

export { }
// 这样可以避免全局作用域污染
// 并确保类型声明仅在需要时生效
// 例如在 Vue 组件或其他 TypeScript 文件中
// 可以直接使用 ElMessage 而不会报错
// 例如： ElMessage.success('操作成功')
```

**<font style="color:#01B2BC;">Element Plus 自动按需插件</font>**

允许自动导入Element Plus组件，无需手动import每个组件，同时自动识别 components 下的通用组件

```bash
pnpm add -D unplugin-vue-components unplugin-auto-import
```

<font style="color:rgb(51, 51, 51);">把下列代码插入到的 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Vite</font>`<font style="color:rgb(51, 51, 51);"> 或 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">Webpack</font>`<font style="color:rgb(51, 51, 51);"> 的配置文件中</font>

`vite.config.js`

```javascript
...
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    ...
    AutoImport({
      resolvers: [ElementPlusResolver()]
    }),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ]
})
```

<font style="color:rgb(51, 51, 51);">直接使用</font>

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1752576490115-c1da0128-b0be-421c-92ea-e4320a4bbe4d.png)

```vue
<template>
  <div>
    <el-button type="primary">Primary</el-button>
    <el-button type="success">Success</el-button>
    <el-button type="info">Info</el-button>
    <el-button type="warning">Warning</el-button>
    <el-button type="danger">Danger</el-button>
    ...
  </div>
</template>
```

:::color4
**<font style="color:rgb(51, 51, 51);"></font>**<font style="color:rgb(51, 51, 51);">默认</font>**<font style="color:#01B2BC;"> components</font>**<font style="color:rgb(51, 51, 51);"> 下的文件也会被自动注册~无需导入组件，直接在<template>中使用</font>

:::

**<font style="color:#01B2BC;">使用Element Plus并设置中文语言</font>**

修改使用过程中某些组件，例如分页插件步长、总数等显示文本

main.ts

```typescript
import { createApp } from 'vue'
import pinia from './stores/index' // 导入已配置的pinia实例

import App from './App.vue'
import router from './router'
import '@/assets/style/main.scss' // 全局样式

// 引入Element Plus及其中文语言包
import ElementPlus from 'element-plus'
import zhCn from 'element-plus/es/locale/lang/zh-cn'

const app = createApp(App)

app.use(pinia) // 使用已配置的pinia实例
app.use(router)
// 使用Element Plus并设置中文语言
app.use(ElementPlus, {
  locale: zhCn,
})

app.mount('#app')

```

**<font style="color:#01B2BC;">Mapbox GL（地图框架）</font>**

<font style="color:rgba(0, 0, 0, 0.85);">开源的交互式地图框架</font>

```bash
pnpm install mapbox-gl
```

**<font style="color:#01B2BC;">Axios（接口请求）</font>**

<font style="color:rgba(0, 0, 0, 0.85);">一个基于 Promise 的 HTTP 客户端，用于在浏览器和 Node.js 中发送网络请求</font>

```bash
pnpm install axios
```

**<font style="color:#01B2BC;">sass 依赖</font>**

<font style="color:rgba(0, 0, 0, 0.85);">CSS 预处理器，扩展了原生 CSS 的功能</font>

```bash
pnpm add sass -D
```

**<font style="color:#01B2BC;">echarts 依赖</font>**

<font style="color:rgba(0, 0, 0, 0.85);">百度开源的强大数据可视化库，支持生成各种交互式图表（折线图、柱状图、饼图、雷达图、地图等）</font>

```bash
pnpm add echarts
```

**<font style="color:#01B2BC;">lodash 依赖</font>**

<font style="color:rgba(0, 0, 0, 0.85);">JavaScript 实用工具库，提供了大量封装好的工具函数，深拷贝、函数节流 / 防抖等</font>

```bash
pnpm add lodash
```

**<font style="color:#01B2BC;">pinia 持久化 pinia-plugin-persistedstate</font>**

<font style="color:rgba(0, 0, 0, 0.85);">Pinia（Vue 官方推荐的状态管理库）的插件，用于状态持久化</font>

```bash
pnpm add pinia-plugin-persistedstate -D
```

### <font style="color:rgb(51, 51, 51);">ESLint & prettier 配置</font>
<font style="color:rgb(64, 64, 64);">在代码格式化工具链中，</font>**<font style="color:rgb(64, 64, 64);">ESLint 和 Prettier 的规则配置应该明确分工</font>**

**<font style="color:#01B2BC;">VS Code settings.json</font>**

```javascript
// 关闭保存自动格式化
"editor.formatOnSave": false,

// 当保存的时候，eslint自动修复错误
"editor.codeActionsOnSave": {
  "source.fixAll": "explicit"
},
```

**<font style="color:#01B2BC;">配置文件 </font>****<font style="color:#01B2BC;">eslint.config.js</font>**

```javascript
import { defineConfig, globalIgnores } from 'eslint/config'
import globals from 'globals'
import js from '@eslint/js'
import pluginVue from 'eslint-plugin-vue'
// 只关闭冲突规则，不集成Prettier
// import skipFormatting from '@vue/eslint-config-prettier/skip-formatting'
// 同时处理代码质量和格式问题
import vuePrettier from '@vue/eslint-config-prettier'

export default defineConfig([
  {
    name: 'app/files-to-lint',
    files: ['**/*.{js,mjs,jsx,vue}']
  },
  globalIgnores(['**/dist/**', '**/dist-ssr/**', '**/coverage/**']),

  {
    languageOptions: {
      globals: {
        ...globals.browser
      }
    }
  },

  js.configs.recommended,
  ...pluginVue.configs['flat/essential'],
  // skipFormatting,
  vuePrettier, // 集成Prettier
  // 自定义规则
  {
    rules: {
      //  Vue 组件命名需遵循多单词命名规则，'warn'表示当违反此规则时给出警告提示
      // { ignores: ['index'] }表示名为index的组件可忽略此规则检查
      'vue/multi-word-component-names': ['warn', { ignores: ['index'] }],
      'vue/no-setup-props-destructure': 'off'
    }
  }
])

```

**<font style="color:#DF2A3F;"></font>**

**<font style="color:#01B2BC;">配置文件 .prettierrc.json</font>**

<font style="color:rgb(51, 51, 51);">prettier 风格配置 </font>[<font style="color:rgb(65, 131, 196);">https://prettier.io</font>](https://prettier.io/docs/en/options.html)

```json
{
  "printWidth": 80,           
  "tabWidth": 2,            
  "useTabs": false,         
  "semi": true,              
  "singleQuote": true,     
  "trailingComma": "es5",   
  "bracketSpacing": true,    
  "jsxBracketSameLine": false, 
  "arrowParens": "always", 
  "proseWrap": "preserve",  
  "endOfLine": "lf"     
}
```

```vue
  "printWidth": 80,           // 每行代码最大长度
  "tabWidth": 2,             // 每个缩进级别的空格数
  "useTabs": false,          // 是否使用制表符代替空格缩进
  "semi": true,              // 句末是否使用分号
  "singleQuote": true,       // 是否使用单引号代替双引号
  "trailingComma": "es5",    // 多行时是否使用拖尾逗号（none|es5|all）
  "bracketSpacing": true,    // 对象字面量的大括号内是否有空格
  "jsxBracketSameLine": false, // JSX 的右尖括号是否放在最后一行的末尾
  "arrowParens": "always",   // 箭头函数参数是否使用括号（always|avoid）
  "proseWrap": "preserve",   // 格式化 Markdown 时是否换行（always|never|preserve）
  "endOfLine": "lf"          // 行尾换行符（lf|crlf|cr|auto）
```

### <font style="color:rgb(51, 51, 51);">基于 husky 的代码检查工作流</font>
<font style="color:rgb(51, 51, 51);">husky 是一个 git hooks 工具 ( git的钩子工具，可以在特定时机执行特定的命令 )</font>

**<font style="color:#DF2A3F;">git初始化 </font>**

```bash
git init
```

**<font style="color:#DF2A3F;">初始化 husky 工具配置</font>**<font style="color:rgb(51, 51, 51);"> </font>[<font style="color:rgb(65, 131, 196);">https://typicode.github.io/husky/</font>](https://typicode.github.io/husky/)

```bash
pnpm dlx husky-init
pnpm install
```

**<font style="color:#DF2A3F;">修改 .husky/pre-commit 文件</font>**

```bash
pnpm lint
```

### 暂存区 ESlint 校验
**<font style="color:rgb(51, 51, 51);">问题：</font>**<font style="color:rgb(51, 51, 51);">默认进行的是全量检查，耗时问题，历史问题</font>

**<font style="color:rgb(51, 51, 51);">lint-staged 配置</font>**

**<font style="color:#01B2BC;">安装 lint-staged</font>**

```bash
pnpm i lint-staged -D
```

**<font style="color:#01B2BC;">配置 </font>**`**<font style="color:#01B2BC;background-color:rgb(243, 244, 244);">package.json </font>**`**<font style="color:#01B2BC;background-color:rgb(243, 244, 244);"> </font>****<font style="color:#01B2BC;">lint-staged 命令</font>**

```json
{
  // ... 省略 ...
  "lint-staged": {
    "*.{js,ts,vue}": [
      "eslint --fix"
    ]
  }
}

{
  "scripts": {
    // ... 省略 ...
    "lint-staged": "lint-staged"
  }
}
```

**<font style="color:#01B2BC;">修改 .husky/pre-commit 文件</font>**

```vue
pnpm lint-staged
```

### <font style="color:rgb(51, 51, 51);">调整项目目录</font>
```plain
fire-hydrant-frontend/                 # 项目根目录
├── src/                              # 源代码主目录
│   ├── api/                          # API接口定义
│   │   ├── geoserver.ts             # 地理信息系统相关API
│   │   └── user.ts                  # 用户相关API
│   ├── assets/                      # 静态资源
│   │   └── style/                   # 样式文件
│   │       └── main.scss           # 主样式文件
│   ├── components/                 # 可复用组件
│   │   ├── HeaderComponent.vue     # 页面头部组件
│   │   ├── MapComponent.vue        # 地图组件（核心）
│   │   ├── MapInfo.vue             # 地图信息显示组件
│   │   ├── MapToolbar.vue          # 地图工具栏组件
│   │   ├── NavigationComponent.vue  # 导航组件
│   │   └── TableComponent.vue      # 表格组件
│   ├── router/                     # 路由配置
│   │   └── index.ts                # 路由定义文件
│   ├── stores/                     # 状态管理
│   │   ├── modules/                # 状态模块
│   │   │   ├── counter.ts          # 计数器状态示例
│   │   │   ├── mapStore.ts         # 地图相关状态
│   │   │   └── userStore.ts        # 用户相关状态
│   │   └── index.ts                # 状态管理入口
│   ├── utils/                      # 工具函数
│   │   └── request.ts              # 请求封装工具
│   ├── views/                      # 页面视图
│   │   ├── Index.vue               # 首页
│   │   ├── auth/                   # 认证相关页面
│   │   │   └── LoginPage.vue       # 登录页面
│   │   ├── dashboard/              # 仪表板页面
│   │   │   ├── DashboardPage.vue   # 仪表板主页
│   │   │   └── children/           # 仪表板子页面
│   │   │       ├── FireHydrantInfoTable.vue  # 消防栓信息表
│   │   │       └── UserInfoManage.vue        # 用户信息管理
│   │   ├── map/                    # 地图相关页面
│   │   │   └── MapPage.vue         # 地图页面
│   │   └── user/                   # 用户相关页面
│   │       ├── UserPage.vue        # 用户主页
│   │       └── children/           # 用户子页面
│   │           ├── UserHome.vue    # 用户首页
│   │           ├── UserInfo.vue    # 用户信息
│   │           └── UserResetPwd.vue # 用户重置密码
│   ├── App.vue                     # 根组件
│   └── main.ts                     # 应用入口文件
├── public/                         # 公共静态资源目录
├── .env                            # 环境变量配置
├── .gitignore                      # Git忽略文件配置
├── README.md                       # 项目说明文档
├── index.html                      # HTML模板文件
├── package.json                    # 项目配置和依赖定义
├── tsconfig.json                   # TypeScript配置
├── tsconfig.app.json               # 应用TypeScript配置
├── tsconfig.node.json              # Node环境TypeScript配置
├── vite.config.ts                  # Vite构建配置
├── eslint.config.ts                # ESLint代码检查配置
└── .prettierrc.json                # Prettier代码格式化配置
```

<font style="color:rgb(51, 51, 51);">将项目需要的全局样式和 图片文件，复制到 assets 文件夹中</font>

<font style="color:rgb(51, 51, 51);">将全局样式在main.js中引入</font>

```javascript
import '@/assets/main.scss'

// 清除默认样式间距
*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
```

## 基础配置
### <font style="color:rgb(51, 51, 51);">路由基础代码解析</font>
```javascript
import { createRouter, createWebHistory } from 'vue-router'

// createRouter 创建路由实例，===> new VueRouter()
// history模式: createWebHistory()   http://xxx/user
// hash模式: createWebHashHistory()  http://xxx/#/user

// vite 的配置 import.meta.env.BASE_URL 是路由的基准地址，默认是 ’/‘
// https://vitejs.dev/guide/build.html#public-base-path

// 如果将来部署的域名路径是：http://xxx/my-path/user
// vite.config.ts  添加配置  base: my-path，路由就会加上 my-path 前缀

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: []
})

export default router
```

`**<font style="color:#DF2A3F;">import.meta.env.BASE_URL</font>**`<font style="color:rgb(51, 51, 51);"> 是Vite 环境变量</font>

<font style="color:rgb(51, 51, 51);"></font>[<font style="color:rgb(65, 131, 196);">https://cn.vitejs.dev/guide/env-and-mode.html</font>](https://cn.vitejs.dev/guide/env-and-mode.html)

**<font style="color:#01B2BC;">vite.config.js</font>**

```javascript
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import vueDevTools from 'vite-plugin-vue-devtools'
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vite.dev/config/
export default defineConfig({
......
  base: '/',
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

```

<font style="color:#01B2BC;">路由跳转</font>

```javascript
<script setup>
import { RouterLink, RouterView } from 'vue-router'
import HelloWorld from './components/HelloWorld.vue'
// vue3组合式api
// setup中无法获取this
// 获取路由对象
// const router = useRouter()
// 获取路由信息
// const route = useRoute()
import { useRouter, useRoute } from 'vue-router'
const router = useRouter()
const route = useRoute()
const goAbout = () => {
  // this.$router.push('/about')
  route.push('/about')
  console.log(route, router)
}
```

### <font style="color:rgb(51, 51, 51);">Pinia 配置仓库统一管理</font>
**<font style="color:rgb(51, 51, 51);">pinia 独立维护</font>**

<font style="color:rgb(51, 51, 51);">初始化代码在 main.js 中，仓库代码在 stores 中，代码分散职能不单一</font>

**<font style="color:rgb(51, 51, 51);">优化：由 stores 统一维护，在 stores/index.js 中完成 pinia 初始化，交付 main.js 使用</font>**

<font style="color:rgb(51, 51, 51);">导入路径统一 </font>`<font style="color:rgb(51, 51, 51);background-color:rgb(243, 244, 244);">./stores/index</font>`

<font style="color:rgb(51, 51, 51);">仓库维护在</font>**<font style="color:#DF2A3F;"> stores/modules </font>**<font style="color:rgb(51, 51, 51);">中</font>

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756208943808-9d93cb6a-f6b3-48e3-980d-9660568024dc.png)

**<font style="color:#01B2BC;">pinia 持久化插件 pinia-plugin-persistedstate</font>**

```bash
pnpm add pinia-plugin-persistedstate -D
```

**<font style="color:#01B2BC;">stores/index.ts </font>**

```javascript
import { createPinia } from 'pinia'
import persist from 'pinia-plugin-persistedstate'
const pinia = createPinia()
pinia.use(persist)
export default pinia
// import { useUserStore } from './modules/user'
// import { useCountStore } from './modules/counter'
// export { useUserStore, useCountStore }
export * from './modules/user'
export * from './modules/counter'
```

**<font style="color:#01B2BC;">main.ts</font>**

注意不要再新建 pinia 了，导入已配置的pinia实例

```javascript
import { createApp } from 'vue'
import pinia from './stores/index' // 导入已配置的pinia实例

import App from './App.vue'
import router from './router'
import '@/assets/style/main.scss' // 全局样式

const app = createApp(App)

app.use(pinia) // 使用已配置的pinia实例
app.use(router)

app.mount('#app')
```

**<font style="color:#01B2BC;">在 .vue 组件中使用</font>**

```javascript
// 导入useUserStore
// import { useUserStore } from '@/stores/modules/user'
// import { useCountStore } from '@/stores/modules/counter'
import { useUserStore, useCountStore } from '@/stores/index'
const userStore = useUserStore()
const countStore = useCountStore()
```

### <font style="color:rgb(0, 0, 0);">Axios 封装</font><font style="color:rgb(51, 51, 51);">请求工具</font>
<font style="color:rgba(0, 0, 0, 0.85);">统一处理请求地址、请求头、错误提示，避免重复代码</font>

+ 创建 axios 实例，基准地址、超时时间等
+ 请求拦截器：发送请求之前做什么，请求错误做什么
+ 响应拦截器：处理相应数据，业务失败处理等

<font style="color:rgb(51, 51, 51);">对 axios 进行基本的二次封装, 单独封装到一个模块中, 便于使用</font>

**<font style="color:#DF2A3F;">安装 axios</font>**

```javascript
pnpm add axios
```

**<font style="color:#DF2A3F;">新建 </font>**`**<font style="color:#DF2A3F;background-color:rgb(243, 244, 244);">utils/request.js</font>**`**<font style="color:#DF2A3F;"> 封装 axios 模块</font>**

利用 axios.create 创建一个自定义的 axios 来使用

[<font style="color:rgb(65, 131, 196);">http://www.axios-js.com/zh-cn/docs/#axios-create-config</font>](http://www.axios-js.com/zh-cn/docs/#axios-create-config)

```javascript
import axios from 'axios'
const request = axios.create({
  baseURL: 'http://localhost:8080', // 后端基础路径
  timeout: 5000, // 请求超时时间
  headers: {
    'Content-Type': 'application/json', // 默认请求头
  },
})
// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 发送请求之前
    return config
  },
  (error) => {
    // 请求错误
    ElMessage.error('请求错误，请稍后再试')
    return Promise.reject(error)
  }
)
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 响应数据行为
    return response
  },
  (error) => {
    // 响应错误
    ElMessage.error('服务器响应错误')
    return Promise.reject(error)
  }
)
export default request
```



# 页面架构设计
## 页面预览
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757248650630-49a17760-2da8-4392-9dee-a0d48b43d327.png)

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757248708479-4c257fc1-6553-42b1-a248-7a60cde8c100.png)

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757248743516-b54ca67c-5766-4ec9-ba72-788e8b048c3d.png)

## <font style="color:rgb(51, 51, 51);">首页整体路由设计</font>
| **<font style="color:rgb(51, 51, 51);">path</font>** | **<font style="color:rgb(51, 51, 51);">文件</font>** | **<font style="color:rgb(51, 51, 51);">功能</font>** | **<font style="color:rgb(51, 51, 51);">组件名</font>** |
| --- | --- | --- | :--- |
| / | views/Index.vue | 架子 | Index.vue |
| <font style="color:rgb(51, 51, 51);">/login</font> | <font style="color:rgb(51, 51, 51);">views/auth/LoginPage.vue</font> | <font style="color:rgb(51, 51, 51);">登录注册</font> | <font style="color:rgb(51, 51, 51);">LoginPage</font> |
| <font style="color:rgb(51, 51, 51);">/map</font> | <font style="color:rgb(51, 51, 51);">views/map/MapPage.vue</font> | <font style="color:rgb(51, 51, 51);">地图页面</font> | <font style="color:rgb(51, 51, 51);">MapPage</font> |
| <font style="color:rgb(51, 51, 51);">/user</font> | <font style="color:rgb(51, 51, 51);">views/user/UserPage.vue</font> | <font style="color:rgb(51, 51, 51);">用户架子</font> | <font style="color:rgb(51, 51, 51);">UserPage</font> |
| <font style="color:rgb(51, 51, 51);">/user/home</font> | <font style="color:rgb(51, 51, 51);">views/user/UserHome.vue</font> | <font style="color:rgb(51, 51, 51);">个人主页</font> | <font style="color:rgb(51, 51, 51);">UserHome</font> |
| <font style="color:rgb(51, 51, 51);">/user/setting</font> | <font style="color:rgb(51, 51, 51);">views/user/children/UserSetting.vue</font> | <font style="color:rgb(51, 51, 51);">个人设置</font> | <font style="color:rgb(51, 51, 51);">UserSetting</font> |
| <font style="color:rgb(51, 51, 51);">/user/repwd</font> | <font style="color:rgb(51, 51, 51);">views/user/children/UserRepassword.vue</font> | <font style="color:rgb(51, 51, 51);">重置密码</font> | <font style="color:rgb(51, 51, 51);">UserRepassword</font> |


![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756387156877-8333bc02-aee3-44f7-9489-61600655ffa6.png)

**<font style="color:#DF2A3F;">src\router\index.js</font>**

```javascript
import { createRouter, createWebHistory } from 'vue-router'
// 创建路由实例 createRouter
const router = createRouter({
  // 模式 hash history
  // history: createWebHistory(), 地址栏不带#
  // hash: createWebHashHistory(), 地址栏带#
  // vite 中的环境变量.meta.env.BASE_URL
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    // 首页
    {
      path: '/',
      name: 'index',
      component: () => import('@/views/index.vue'),
      redirect: '/map',
      children: [
        // 用户页面
        {
          path: '/user',
          name: 'user',
          component: () => import('@/views/user/UserPage.vue'),
        },
        // 地图页面
        {
          path: '/map',
          name: 'map',
          component: () => import('@/views/map/MapPage.vue'),
        },
      ],
    },
    // 登录页面
    {
      path: '/login',
      name: 'login',
      component: () => import('@/views/auth/LoginPage.vue'),
    },
  ],
})

export default router
```

## 页面基础架构
```vue
<script lang="ts" setup></script>
<template>
  <div class="common-layout">
    <!-- 头部 -->
    <header-component></header-component>
    <!-- 主体部分 -->
    <div class="container">
      <!-- 路由占位符 决定放地图 /用户界面 -->
      <router-view></router-view>
    </div>
    <!-- 底部 -->
    <div class="footer">
      <p>Copyright © 2025 陈凌霄 用于webgis学习</p>
    </div>
  </div>
</template>
<style scoped>
  .common-layout {
    height: 100vh;
    width: 100vw;
    display: flex;
    flex-direction: column;
    /* 垂直方向 */
  }

  .container {
    flex: 1;
    /* 填充剩余空间 */
    overflow: hidden;
  }

  /* 浮动在底部 */
  .footer {
    /* 浮动 */
    position: absolute;
    bottom: 1px;
    width: 100%;
    font-size: 12px;
    text-align: center;
  }
</style>
```

## 头部组件
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756899880386-174bd4a8-0b5e-46e9-bc2c-939769c1fef0.png)

```vue
<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import { useRouter } from 'vue-router'
import { useUserStore } from '@/stores/index'
import { User } from '@element-plus/icons-vue'
const userStore = useUserStore()
const route = useRoute() // 获取当前路由信息
const router = useRouter() // 用于编程式导航
// 计算属性：应该激活的顶级菜单项
const activeMenu = computed(() => {
  const path = route.path
  if (path.includes('/map')) {
    return '/map'
  } else if (path.includes('/dashboard')) {
    return '/dashboard'
  } else if (path.includes('/user')) {
    return '/user'
  } else {
    return path
  }
})
// 退出登录
const logout = () => {
  userStore.clearUserInfo() // 清空用户信息
  // 跳转到登录页面
  router.push('/login')
}
const toInfo = () => {
  router.push('/user/info')
}
const toRepwd = () => {
  router.push('/user/repassword')
}
</script>
<template>
  <header class="header">
    <!-- logo -->
    <div class="header-logo">
      <img src="../assets/logo.png" alt="" />
      <span class="logo-text">市政消防栓管理系统</span>
      <span class="logo-version">0.0.1</span>
    </div>
    <!-- 菜单栏 -->
    <div class="header-nav">
      <el-menu mode="horizontal" :default-active="activeMenu" router>
        <el-menu-item index="/map">首页</el-menu-item>
        <el-menu-item index="/dashboard">控制台</el-menu-item>
        <!-- 主题开关（示例：控制深色模式） -->
        <!-- <div class="header-actions">
          <theme-toggle></theme-toggle>
        </div> -->
        <el-dropdown>
          <div class="user-info">
            <div class="user-icon">
              <el-icon color="#fff" :size="24"><User /></el-icon>
            </div>
            <div class="user-name">
              <p>{{ userStore.userInfo?.name }}</p>
            </div>
          </div>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item @click="toInfo()">基本资料</el-dropdown-item>
              <el-dropdown-item @click="toRepwd()">重置密码</el-dropdown-item>
              <el-dropdown-item @click="logout()">退出登录</el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </el-menu>
    </div>
  </header>
</template>

<style>
.header {
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #ebeef5;
  position: relative;
  z-index: 10;
}

.header-logo {
  display: flex;
  align-items: center;
}

.header-logo img {
  width: 40px;
  margin-right: 10px;
}

.header-logo .logo-text {
  font-size: 18px;
  font-weight: bold;
  color: #409eff;
}

.header-logo .logo-version {
  margin-left: 8px;
  font-size: 12px;
  color: #999;
}

/* 导航栏 */
.header-nav {
  margin-right: 10px;
  width: 350px;
}
.el-dropdown {
  display: flex;
  align-items: center;
  cursor: pointer;
  margin-left: 10px;
}
.el-dropdown .user-info {
  display: flex;
  align-items: center;
}
.el-dropdown .user-icon {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background-color: #409eff;
  margin-right: 8px;
}

.el-dropdown .user-icon .el-icon {
  /* 居中 */
  height: 100%;
  width: 100%;
}
.el-dropdown .user-name {
  font-size: 14px;
  color: #333;
  font-weight: bold;
}
</style>

```

# 登录注册功能
## 前端页面结构
### 页面预览
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756741563726-32af7719-d475-42fa-a5aa-5c33d9056e79.png)

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756741532532-0add6dfe-1a94-49d6-acc0-34dc1fe225a3.png)

### 实现逻辑
定义`isLogin = ref(true)`：`true`对应 **登录页**，`false`对应 **注册页**，视图切换

实现`toggleisLogin()`函数：绑定到 **点击注册/返回登录 **链接的`@click`事件，触发视图切换

**表单引用预留：**

+ 声明`loginForm`/`registerForm`两个`ref`，绑定到对应`el-form`的`ref`属性
+ 为后续表单验证（如必填项、密码一致性校验）预留接口

<font style="color:rgba(0, 0, 0, 0.85);">Vue 内置</font>`<font style="color:rgba(0, 0, 0, 0.85);"><transition></font>`<font style="color:rgba(0, 0, 0, 0.85);">组件实现视图切换动画</font>

```vue
<script lang="ts" setup>
  import { User, Lock } from '@element-plus/icons-vue'
  import { ref } from 'vue'
  // 登录状态（true=登录，false=注册）
  const isLogin = ref(true)
  // 分别定义登录/注册表单ref
  const loginForm = ref(null)
  const registerForm = ref(null)

  // 切换登录/注册状态
  const toggleisLogin = () => {
    isLogin.value = !isLogin.value
  }
</script>

<template>
  <div class="auth-container">
    <!-- 过渡动画：添加mode="out-in"确保「先出后入」，避免元素重叠 -->
    <transition name="auth-transition" mode="out-in">
      <!-- 登录表单 -->
      <div class="login-page" v-if="isLogin" key="login">
        <el-form ref="loginForm" size="large" autocomplete="off" class="form">
        </el-form>
      </div>
      <!-- 注册表单 -->
      <div class="register-page" v-else key="register">
        <div class="register-info">
          <h1 class="info-title">欢迎注册</h1>
          <p class="info-desc">立即注册，探索更多精彩功能</p>
          <div class="info-divider"></div>
          <p class="info-tip">注册后可享受：</p>
          <ul class="info-list">
            <li>· 没编号</li>
            <li>· 多设备同步</li>
            <li>· 专属服务支持</li>
          </ul>
        </div>
        <el-form
          ref="registerForm"
          size="large"
          autocomplete="off"
          class="form"
          >
        </el-form>
      </div>
    </transition>
  </div>
</template>
```

## 数据库设计
### <font style="color:rgb(0, 0, 0);">用户信息表（Users）</font>
| **序号** | **字段名称** | **字段说明** | **字段类型** | **备注** |
| :--- | :--- | :--- | :--- | :--- |
| 1 | Id | 用户编号 | Int | 主键，自增 |
| 2 | Name | 用户名 | Varchar(50) | 非空 |
| 3 | Password | 用户密码 | Varchar(50) | 非空 |
| 4 | role | 用户权限 | Varchar(20) | 默认‘USER’ |
| 5 | Sex | 用户性别 | Varchar(5) | |
| 6 | BirthDate | 出生日期 | Date | |
| 7 | Department | 所属部门 | Varchar(50) | |
| 8 | Telephone | 联系电话 | Varchar(50) | |
| 9 | EMail | 电子邮箱 | Varchar(50) | |


### SQL 语句
```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  password VARCHAR(50) NOT NULL,
  role VARCHAR(20) NOT NULL DEFAULT 'USER'
  sex VARCHAR(5),
  birth_date DATE,
  department VARCHAR(50),
  telephone VARCHAR(50),
  email VARCHAR(50)
);
```

## 后端设计
<font style="color:rgb(0, 0, 0);">Maven+Spring Boot+MyBatis-Plus 笔记</font>

 [Spring Initializr](https://start.spring.io/)（在线生成项目骨架）

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756551166112-1710b82c-b74c-499b-a6e6-b60825242c51.png?x-oss-process=image%2Fformat%2Cwebp)

### <font style="background-color:rgb(249, 250, 251);">连接数据库配置</font>
```properties
#配置当前 Spring Boot 应用的名称
spring.application.name=fire-hydrant-management
# 配置应用启动时绑定的端口号
server.port=8080

# 数据库连接配置（PostgresSQL）
spring.datasource.url=jdbc:postgresql://localhost:5432/fire_hydrant_data
spring.datasource.username=postgres
spring.datasource.password=123456
# MyBatis-Plus 框架配置
# 指定 MyBatis 映射文件（XML）的位置
# 在项目的类路径（classpath）下的mapper文件夹中，所有.xml文件都会被 MyBatis-Plus 加载
# 这些 XML 文件通常定义 SQL 语句和映射关系）在项目的类路径（classpath）下的mapper文件夹中
mybatis-plus.mapper-locations=classpath:mapper/*.xml
# 配置实体类（Entity）的包路径
# 在 XML 映射文件中引用实体类时，可以直接使用类名（如User）而无需写全限定名（如com.example...User），简化配置
mybatis-plus.type-aliases-package=com.example.fire_hydrant_management.entity
#配置 MyBatis 的日志输出方式，这里指定为控制台输出（StdOutImpl）
#作用：开发时可在控制台查看 MyBatis 生成的 SQL 语句，方便调试
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl

# 配置 MyBatis-Plus 的日志输出级别 为debug
logging.level.com.example.firehydrantmanagement.mapper=debug
```

### Entity 映射数据库表 
**@Data **（Lombok 注解）自动为类中的所有字段生成getter、setter方法  
如果注解失效搞不定，可以手动写getter、setter方法

```java
package com.example.fire_hydrant_management.entity; // 实体类所在的包名
import java.util.Date; //用于处理日期类型数据（对应数据库的日期字段)
//MyBatis-Plus 的核心注解，用于实体类与数据库表的映射配置
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableName;
// lombok注解，用于生成getter和setter方法
import lombok.Data;

@Data//（Lombok 注解）
// 自动为类中的所有字段生成getter、setter方法
// 同时生成toString()、equals()、hashCode()等方法，避免手动编写这些重复代码
@TableName("\"users\"") // （MyBatis-Plus 注解）
// 表示实体类对应的数据库表名 "\"users\""使用双引号转义
// 很多数据库（如 MySQL、PostgreSQL）的关键字（保留字）
// 直接使用可能导致 SQL 语法错误，通过转义可以明确表示表名为users
public class users {
    // @TableId：标识当前字段是数据库表的主键
    // type属性 指定主键生成策略为 "自增"，即数据库会自动为该列生成递增的唯一值（需数据库表的id列本身设置为自增）
    @TableId(value = "\"id\"", type = IdType.AUTO) // 为id字段添加转义的双引号
    private Integer id;
    // @TableField("\"列名\"")用于指定非主键字段与数据库列的映射关系，同样通过转义处理可能的关键字
    @TableField("\"name\"")
    private String name;

    @TableField("\"password\"")
    private String password;

    @TableField("\"sex\"")
    private String sex;

    @TableField("\"birth_date\"")
    private Date birthDate;

    @TableField("\"department\"")
    private String department;

    @TableField("\"telephone\"")
    private String telephone;

    @TableField("\"email\"")
    private String email;
}

```

### `@JsonIgnore`和`@JsonProperty`
主要用于控制 Java 对象与 JSON 之间的序列化（对象转 JSON）和反序列化（JSON 转对象）过程

`**<font style="color:#01B2BC;">@JsonIgnore</font>**`**<font style="color:#01B2BC;"> 注解（用于 </font>**`**<font style="color:#01B2BC;">getPassword()</font>**`**<font style="color:#01B2BC;"> 方法）</font>**

+ 在对象序列化（将 Java 对象转换为 JSON 字符串）时，忽略被注解的方法对应的属性
+ 具体来说，`getPassword()` 是 `password` 字段的 getter 方法
+ 当 Jackson 将对象转为 JSON 时，默认会通过 getter 方法获取属性值并写入 JSON
+ 加上 `@JsonIgnore` 后，序列化时会跳过这个 getter 方法
+ 因此生成的 JSON 中**不会包含**`**password**`**字段**，避免敏感的密码信息被暴露（比如接口返回数据）

`**<font style="color:#01B2BC;">@JsonProperty</font>**`**<font style="color:#01B2BC;"> 注解（用于 </font>**`**<font style="color:#01B2BC;">setPassword(String password)</font>**`**<font style="color:#01B2BC;"> 方法）</font>**

+ 在反序列化（将 JSON 字符串转为 Java 对象）时，指定 JSON 中字段与当前 setter 方法的映射关系
+ 具体来说，当 Jackson 解析 JSON 字符串时，会通过 setter 方法给对象的属性赋值
+ `@JsonProperty` 确保 JSON 中的 `password` 字段能被正确映射到该 setter 方法
+ 从而成功设置 `password` 属性的值（比如接收前端传来的密码并保存）

这两个注解配合使用：

+ 避免密码在序列化后（接口响应）被泄露（通过`@JsonIgnore`阻止序列化）；
+ 同时允许在反序列化时（接收用户提交密码）正常设置密码（通过`@JsonProperty`允许反序列化）

这样既保证了敏感信息的安全性，又不影响对象的正常创建 / 更新

```java
@JsonIgnore
public String getPassword() {
    return password;
}
@JsonProperty
public void setPassword(String password) {
    this.password = password;
}
```

### Mapper **声明方法**
`/mapper/UsersMapper`

```java
@Mapper // 标记为MyBatis mapper接口
// Spring 会自动扫描并将其注册为 Bean，使得 Service 层可以通过依赖注入使用它
public interface UsersMapper extends BaseMapper<Users> {
    // BaseMapper已包含基本CRUD方法，无需额外编写
    // 用户注册
    boolean register(Users user);
    // 用户登录
    Users login(String name, String password);
}
```

:::color4
**BaseMapper **已包含基本CRUD方法，无需额外编写

:::

例如：

+ **insert(User entity)：新增一条记录**
+ **updateById(User entity)：根据 ID 更新记录**
+ **selectById(Serializable id)：根据 ID 查询记录**
+ **deleteById(Serializable id)：根据 ID 删除记录**
+ **selectList(Wrapper<User> queryWrapper)：条件查询列表**
+ **如果基础 CRUD 无法满足需求（例如复杂查询、多表关联等）**

可以在UserMapper中自定义方法，有两种实现方式：

+ 注解方式（简单 SQL）
+ XML 映射文件方式（复杂 SQL）

### Mapper XML <font style="color:rgb(0, 0, 0);">映射</font>**实现 SQL**
当 SQL 逻辑复杂（如多表联查、子查询等）时，推荐使用 XML 文件维护 SQL，更易读和维护

**在 UserMapper 接口中声明方法**

```java
@Mapper // 标记为MyBatis mapper接口
// Spring 会自动扫描并将其注册为 Bean，使得 Service 层可以通过依赖注入使用它
public interface UsersMapper extends BaseMapper<Users> {
    // BaseMapper已包含基本CRUD方法，无需额外编写
    // 用户注册
    boolean register(Users user);
    // 用户登录
    Users login(String name, String password);
}
```

**在 XML 文件中实现 SQL**

按照配置文件`mybatis-plus.mapper-locations=classpath:mapper/*.xml`的约定

在项目`resources/mapper`目录下创建`UsersMapper.xml`文件：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--命名空间绑定UserMapper接口-->
<mapper namespace="com.example.fire_hydrant_management.mapper.UsersMapper">
  <!-- 这里其实不需要再定义register和login方法，因为已经在UsersServiceImpl中实现 -->
  <!-- MyBatis-Plus的BaseMapper已经提供了基本的CRUD操作 -->
</mapper>
```

如果需要手动编写：

```xml
<!--注册功能-->
<select id="register" resultType="boolean">
    INSERT INTO "users"("name", "password", "sex", "birth_date", "department", "telephone", "email")
    VALUES (#{name}, #{password}, #{sex}, #{birthDate}, #{department}, #{telephone}, #{email})
</select>
<!-- 登录功能-->
<select id="login" resultType="com.example.fire_hydrant_management.entity.Users">
    SELECT * FROM "users" WHERE "name" = #{name} AND "password" = #{password}
</select>
```

说明：

+ `namespace`需与`UserMapper`接口的全类名完全一致，确保 MyBatis 能关联接口和 XML
+ `id`需与接口中的方法名一致，MyBatis 会通过`namespace+id`找到对应的 SQL
+ `resultType`指定查询结果的映射实体类（如果是多表联查，也可使用`resultMap`自定义字段映射）

### Service 接口和实现类
**Service 接口：**

```java
public interface UsersService extends IService<Users> {
    // 注册接口
    boolean register(Users user);
    // 登录接口
    Users login(String name, String password);
}
```

**ServiceImpl 实现类：**

```java
@Service
// // UserMapper 是 MyBatis 的 Mapper 接口（负责数据库交互），User 是实体类（对应数据库表）
public class UsersServiceImpl extends ServiceImpl<UsersMapper, Users> implements UsersService {
    //注册接口
    @Override // 重写父类的方法
    public boolean register(Users user) {
        QueryWrapper<Users> queryWrapper = new QueryWrapper<>(); // 创建查询条件
        queryWrapper.eq("name", user.getName()); // 设置查询条件为用户名
        Users existUser = baseMapper.selectOne(queryWrapper); // 查询用户
        if (existUser != null) {
            return false; // 用户名已存在
        }
        return save(user); // 保存用户信息
    }
    // 登录接口
    @Override
    public Users login(String name, String password) {
        QueryWrapper< Users> queryWrapper = new QueryWrapper<>(); // 创建查询条件
        queryWrapper.eq("name", name);
        queryWrapper.eq("password", password);
        return baseMapper.selectOne(queryWrapper); // 查询用户
    }
}
```

`**baseMapper**`** 的作用：**

+ `baseMapper` 是 `ServiceImpl` 类中定义的属性，类型为泛型指定的 `UserMapper`
+ 可直接调用 `UserMapper` 定义的所有方法（包括 MyBatis-Plus 自动生成的基础方法和自定义）

`**QueryWrapper**`** 的作用：**

+ MyBatis-Plus 提供的条件构造器，用于动态 SQL 语句中的 `WHERE` 条件（无需手动拼接 SQL）
+ 例如 `eq("name", value)` 对应 `name = value`

**方法覆盖：**

+ `register` 和 `login` 方法使用 `@Override` 注解
+ 明确表示覆盖 `UserService` 接口中的抽象方法



`UsersServiceImpl`类实现了`UsersService`接口，且继承自`ServiceImpl<UsersMapper, Users>`

这里`UserMapper`是 MyBatis 用于数据库交互的 Mapper 接口，`User`是对应数据库表的实体类

`**register**`**方法：**

+ 功能是实现用户注册逻辑
+ 首先创建一个`QueryWrapper`对象`queryWrapper`用于设置查询条件
+ 接着通过`queryWrapper.eq("name", user.getName())`设置查询条件为传入用户对象的用户名，以此来查询数据库中是否已存在该用户名的用户
+ 使用`baseMapper.selectOne(queryWrapper)`执行查询，如果查询到的`existUser`不为空，说明用户名已存在，返回`false`
+ 若用户名不存在，则通过`save(user)`方法将用户信息保存到数据库，返回`true`

`**login**`**方法：**

+ 功能是实现用户登录逻辑
+ 创建`QueryWrapper`对象`queryWrapper`
+ 通过`queryWrapper.eq("name", name)`和`queryWrapper.eq("password", password)`分别设置用户名和密码的查询条件
+ 最后使用`baseMapper.selectOne(queryWrapper)`查询数据库中是否存在匹配用户名和密码的用户，并返回查询结果。如果存在则返回对应的用户对象，不存在则返回`null`

### Controller 处理 HTTP 请求
```java
@RestController // 表示该类是一个 RESTful 控制器
@RequestMapping("/users") // 定义 RESTful 接口路径
public class UsersController {
    @Autowired // 自动注入
    private UsersService usersService; // 创建 UsersService 对象
    // 注册接口
    @PostMapping("/register")
    public Map<String, Object> register(@RequestBody Users user) {
        Map<String, Object> result = new HashMap<>(); // 创建结果对象
        try {
            boolean success = usersService.register(user);
            if (success) {
                result.put("code", 200);
                result.put("message", "注册成功");
            } else {
                result.put("code", 400);
                result.put("message", "用户名已存在");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "注册失败：" + e.getMessage());
        }
        return result;
    }
    // 登录接口
    @PostMapping("/login")
    public Map<String, Object> login(@RequestBody Map<String, String> loginInfo) {
        Map<String, Object> result = new HashMap<>();
        try {
            String name = loginInfo.get("name");
            String password = loginInfo.get("password");
            Users user = usersService.login(name, password);
            if (user != null) {
                result.put("code", 200);
                result.put("message", "登录成功");
                result.put("data", user);
            }
            else {
                result.put("code", 401);
                result.put("message", "用户名或密码错误");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "登录失败：" + e.getMessage());
        }
        return result;
    }

}
```

**<font style="color:rgb(0, 0, 0);">类定义与核心注解</font>**

```java
@RestController
@RequestMapping("/user")
public class UsersController { ... }
```

`@RestController`：Spring MVC 提供的复合注解，等价于 `@Controller + @ResponseBody`

+ `@Controller`：标识该类是一个控制器，用于处理 HTTP 请求
+ `@ResponseBody`：表示方法的返回值会直接作为 HTTP 响应体（而非视图名称）
+ 通常会自动转换为 JSON 格式（方便前后端分离架构的数据交互）

`@RequestMapping("/user")`：

+ 定义当前控制器的基础请求路径，即所有接口的 URL 都以 `/user` 开头
+ 例如注册接口的完整路径是 `/user/register`

**<font style="color:rgb(0, 0, 0);">依赖注入</font>**

```java
@Autowired
private UsersService usersService;
```

`**@Autowired**`：Spring 的自动注入注解

+ 会自动从 Spring 容器中查找 `UserService` 类型的实例并赋值给该变量
+ 控制器通过 `userService` 调用服务层的方法（如注册、登录等），实现「控制器 - 服务层」的解耦

**<font style="color:rgb(0, 0, 0);">接口映射注解</font>**`@PostMapping("/register")`

```java
// 注册接口
@PostMapping("/register")
```

+ 这是 Spring MVC 提供的注解，用于将 HTTP 的`POST`请求映射到当前方法
+ `"/register"`指定了接口的访问路径
+ 客户端需要通过`POST http://服务器地址/register`的方式调用该接口

**<font style="color:rgb(0, 0, 0);">方法定义与参数：</font>**`public Map<String, Object> register(@RequestBody Users user)`

```java
public Map<String, Object> register(@RequestBody Users user) {
    Map<String, Object> result = new HashMap<>(); // 创建结果对象
    try {
        boolean success = usersService.register(user);
        if (success) {
            result.put("code", 200);
            result.put("message", "注册成功");
        } else {
            result.put("code", 400);
            result.put("message", "用户名已存在");
        }
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "注册失败：" + e.getMessage());
    }
    return result;
}
```

**返回值：**`**Map<String, Object>**`

+ 表示接口返回一个键值对集合
+ Spring 会自动将其序列化为 JSON 格式响应给客户端（方便前端解析状态和信息）

**参数**`**@RequestBody Users user**`**：**

`@RequestBody`：

+ Spring 的核心注解，用于将 HTTP 请求体中的 JSON 数据自动转换为`Users`对象
+ 要求请求体 JSON 的字段名与`Users`类的属性名一致
+ 否则需要通过`@JsonProperty`等注解映射

`Users user`：

+ `Users`是一个实体类（通常对应数据库中的用户表），封装了客户端提交的注册信息
+ 如`username`（用户名）、`password`（密码）、`email`（邮箱）等
+ 具体字段取决于`Users`类的定义

响应结果容器：`Map<String, Object> result = new HashMap<>()`

+ 创建`HashMap`统一响应载体，用于存储接口处理的状态码（`code`）和提示信息（`message`）
+ 统一响应格式，让前端可以通过固定的`code`字段判断请求是否成功
+ 通过`message`字段获取具体提示（如 注册成功 或 用户名已存在）

**业务逻辑处理（**`**try**`**块）**

```java
boolean success = usersService.register(user);
if (success) {
    result.put("code", 200);
    result.put("message", "注册成功");
} else {
    result.put("code", 400);
    result.put("message", "用户名已存在");
}
```

**调用 Service 层：**`**usersService.register(user)**`

此处调用业务逻辑层（Service 层）的`register`方法，核心逻辑包括：

+ 校验用户名是否已存在（避免重复注册）；
+ 对密码进行加密处理（如使用 BCrypt 加密，而非明文存储）；
+ 将用户信息保存到数据库（通过 DAO 层操作）

该方法返回`boolean`值：`true`表示注册成功，`false`表示注册失败（通常是因为用户名已存在）

**结果判断与响应设置：**

若`success = true`（注册成功）：

+ 存入`code = 200`（表示 “成功”，对应 HTTP 的 200 状态码语义）和`message = "注册成功"`

若`success = false`（注册失败）：

+ 存入`code = 400`（表示“客户端错误”）和`message = "用户名已存在"`

**异常处理（**`**catch**`**块）**

```java
catch (Exception e) {
    result.put("code", 500);
    result.put("message", "注册失败：" + e.getMessage());
}
```

**作用**：捕获`try`块中可能出现的所有异常（如数据库连接失败、SQL 执行错误、密码加密异常等）

**响应设置**：

+ 存入`code = 500`（表示 “服务器内部错误”）和包含异常信息的`message`便于开发人员排查问题

## Token 配置
`application.properties` 要为登录接口添加 Token 认证，可采用 JWT（JSON Web Token）实现

### 添加 JWT 依赖
在`pom.xml`中添加 JWT 相关依赖：

```xml
<!-- JWT依赖 -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

### 创建 JWT 工具类
用于生成、验证 Token：

`com.example.fire_hydrant_management.utils`

```java
@Component
public class JwtUtils {
    // 从配置文件读取密钥和过期时间
    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expire}")
    private long expire;

    // 创建加密密钥
    private SecretKey getSigningKey() {
        // 使用HMAC-SHA256算法，需要至少256位(32字节)的密钥
        byte[] keyBytes = secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    // 生成Token
    public String generateToken(String username) {
        Date now = new Date();
        Date expirationDate = new Date(now.getTime() + expire);

        return Jwts.builder()
                .setSubject(username) // 设置用户名作为主题
                .setIssuedAt(now) // 签发时间
                .setExpiration(expirationDate) // 过期时间
                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // 使用最新的签名方式
                .compact();
    }

    // 从Token中获取用户名
    public String getUsernameFromToken(String token) {
        Claims claims = Jwts.parserBuilder() // 使用builder模式构建解析器
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
        return claims.getSubject();
    }

    // 验证Token有效性
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            // 包括过期、签名错误等各种JWT异常
            return false;
        }
    }

    // 检查Token是否过期
    public boolean isTokenExpired(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
        Date expiration = claims.getExpiration();
        return expiration.before(new Date());
    }
}
```

### 配置 JWT 参数
在`application.properties`中添加 JWT 配置：

```properties
# JWT配置
jwt.secret=your-very-long-secret-key-should-be-at-least-32-chars
# 2小时过期
jwt.expire=7200000
```

### 登录接口返回 Token
<font style="background-color:rgb(249, 250, 251);">在</font>`<font style="background-color:rgb(249, 250, 251);">UsersController</font>`<font style="background-color:rgb(249, 250, 251);">的登录方法中，登录成功后生成 Token 并返回：</font>

```java
@Autowired
private JwtUtils jwtUtils; // 注入JWT工具类

// 登录接口
@PostMapping("/login")
public Map<String, Object> login(@RequestBody Map<String, String> loginInfo) {
    Map<String, Object> result = new HashMap<>();
    try {
        String name = loginInfo.get("name");
        String password = loginInfo.get("password");
        Users user = usersService.login(name, password);
        if (user != null) {
            // 生成Token
            String token = jwtUtils.generateToken(name);
            
            result.put("code", 200);
            result.put("message", "登录成功");
            result.put("data", user);
            result.put("token", token); // 返回Token给前端
        } else {
            result.put("code", 401);
            result.put("message", "用户名或密码错误");
        }
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "登录失败：" + e.getMessage());
    }
    return result;
}
```

### 创建 Token 拦截器（保护其他接口）
`com.example.fire_hydrant_management.interceptor`

<font style="background-color:rgb(249, 250, 251);">用于验证请求中的 Token 有效性：</font>

```java
public class TokenInterceptor implements HandlerInterceptor {
    @Autowired
    private JwtUtils jwtUtils;
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 排除登录和注册接口
        String path = request.getRequestURI();
        if (path.contains("/users/login") || path.contains("/users/register")) {
            return true;
        }

        // 从请求头获取Token
        String token = request.getHeader("Authorization");
        if (token == null || !jwtUtils.validateToken(token)) {
            // Token无效或不存在，返回401
            response.setContentType("application/json;charset=UTF-8");
            PrintWriter out = response.getWriter();
            out.write("{\"code\":401,\"message\":\"未授权访问，请先登录\"}");
            out.flush();
            out.close();
            return false;
        }
        return true;
    }
}
```

### <font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">注册拦截器</font>
创建配置类，注册拦截器：

`com.example.fire_hydrant_management.config`

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Bean
    public TokenInterceptor tokenInterceptor() {
        return new TokenInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截所有请求，排除登录和注册接口
        registry.addInterceptor(tokenInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/users/login", "/users/register");
    }
}
```



## 接口测试
### 注册接口
**请求方法**：POST

**请求路径**：`/users/register`

**参数类型**：Request Body（JSON）

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| name | String | 用户名（唯一） | 是 |
| password | String | 密码 | 是 |
| sex | String | 性别（可选） | 否 |
| birthDate | Date | 出生日期（可选） | 否 |
| department | String | 部门（可选） | 否 |
| telephone | String | 电话（可选） | 否 |
| email | String | 邮箱（可选） | 否 |


**示例请求参数**：

```json
{
  "name": "testUser",
  "password": "123456",
}
```

**示例返回值**：

+ 成功（用户名不存在）：

```json
{
  "code": 200,
  "message": "注册成功"
}
```

+ 失败（用户名已存在）：

### 登录接口
**请求方法**：POST

**请求路径**：`/users/login`

**参数类型**：Request Body（JSON）

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| name | String | 用户名 | 是 |
| password | String | 密码 | 是 |


**示例请求参数**：

```json
{
  "name": "test01",
  "password": "123456"
}
```

**示例返回值**：

+ 成功（用户名密码正确）：
+ 失败（用户名或密码错误）：

响应结果

```json
{
  "code": 200,
  "data": {
    "id": 2,
    "name": "12138",
    "password": "123456",
    "sex": "男",
    "birthDate": "1989-12-31T16:00:00.000+00:00",
    "department": "技术部",
    "telephone": "13800138000",
    "email": "test@example.com"
    "role": "ADMIN"
  },
  "message": "登录成功",
  "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMjEzOCIsImlhdCI6MTc1NjcyODU3NiwiZXhwIjoxNzU2NzM1Nzc2fQ.IuJktuf9bbuYWNOEGG5kaSjmqu8QOEQX-71zv7IT7z8"
}
```

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756730990740-6a98d234-5ab8-4453-b841-0caa6cee83c7.png)

## 登录注册功能实现
### 用户<font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">状态管理 UserStore</font>
定义`UserInfo`接口规范用户信息格式

提供存储和获取用户信息、token 的方法

添加持久化存储配置，避免页面刷新后登录状态丢失

简单的登录状态判断方法

```vue
import { defineStore } from 'pinia'
import { ref } from 'vue'

// 用户信息类型定义
interface UserInfo {
  id: number
  name: string
  sex: string
  birthDate: string
  department: string
  telephone: string
  email: string
  role: string
}

// 用户模块
export const useUserStore = defineStore(
  'user',
  () => {
    // 存储用户信息
    const userInfo = ref<UserInfo | null>(null)
    // 存储token
    const token = ref('')
    // 计算属性：从用户信息中获取权限信息
    const role = computed(() => {
      return userInfo.value?.role || ''
    })
    // 设置用户信息
    const setUserInfo = (info: UserInfo) => {
      userInfo.value = info
    }

    // 设置token
    const setToken = (t: string) => {
      token.value = t
    }

    // 清除用户信息（退出登录）
    const clearUserInfo = () => {
      userInfo.value = null
      token.value = ''
    }

    // 判断是否登录
    const isLogin = () => {
      return !!token.value
    }
    
    // 判断是否为管理员
    const isAdmin = () => {
      return role.value === 'ADMIN'
    }

    return {
      userInfo,
      token,
      setUserInfo,
      setToken,
      clearUserInfo,
      isLogin,
      isAdmin,
    }
  },
  {
    // 开启持久化存储，刷新页面后仍保留状态
    persist: true,
  }
)
```

### 配置 Axios <font style="color:rgba(0, 0, 0, 0.85);background-color:rgb(249, 250, 251);">请求封装</font>
<font style="color:rgba(0, 0, 0, 0.85);">创建</font>`<font style="color:rgba(0, 0, 0, 0.85);">src/utils/request.js</font>`<font style="color:rgba(0, 0, 0, 0.85);">封装 Axios：</font>

+ 统一配置基础 URL 和超时时间
+ 请求拦截器添加认证 token
+ 响应拦截器统一处理错误信息
+ 使用 Element Plus 的 Message 组件显示提示信息

```typescript
import axios from 'axios'
import { useUserStore } from '@/stores/index'
import { ElMessage } from 'element-plus'
import router from '@/router'
const request = axios.create({
  baseURL: 'http://localhost:8080', // 基础路径
  timeout: 5000, // 请求超时时间
  headers: {
    // 请求头
    'Content-Type': 'application/json', // 默认请求头
  },
})
// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 在发送请求之前做些什么
    // 添加token 从用户userStore中获取
    const userStore = useUserStore()
    if (userStore.token) {
      config.headers.Authorization = userStore.token
    }
    return config
  },
  (error) => {
    // 对请求错误做些什么
    ElMessage.error('请求错误，请稍后再试')
    return Promise.reject(error)
  }
)
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    // 对响应数据做点什么
    const res = response.data
    if (res.code !== 200) {
      ElMessage.error(res.message || '请求失败，请稍后再试')
      return Promise.reject(new Error(res.message || '请求失败'))
    }
    return response
  },
  (error) => {
    // 对响应错误做点什么
    // 特殊情况 权限不足 token过期
    if (error.response && error.response.status === 401) {
      ElMessage.error('登录已过期，请重新登录')
      const userStore = useUserStore()
      userStore.setToken('') // 清空token
      // 可选：跳转到登录页
      router.push('/login')
    }
    ElMessage.error('服务器响应错误')
    return Promise.reject(error)
  }
)
export default request

```

### <font style="color:rgb(0, 0, 0);">封装用户相关 API</font>
创建`src/api/user.js`封装用户相关 API：

+ 定义了接口所需的 TypeScript 类型
+ 封装了登录、注册、获取用户信息和退出登录接口
+ 统一管理 API 地址，便于维护

```javascript
import request from '@/utils/request'

// 用户登录参数类型
export interface LoginParams {
  name: string
  password: string
}

// 用户注册参数
export interface RegisterParams {
  name: string
  password: string
}

// 登录响应数据类型
export interface LoginResponse {
  code: number
  data: {
    id: number
    name: string
    password: string
    sex: string
    birthDate: string
    department: string
    telephone: string
    email: string
  }
  message: string
  token: string
}

// 注册响应数据类型
export interface RegisterResponse {
  code: number
  message: string
}

// 登录接口
export const login = (data: LoginParams) => {
  return request<LoginResponse>({
    url: '/users/login',
    method: 'POST',
    data,
  })
}

// 注册接口
export const register = (data: RegisterParams) => {
  return request<RegisterResponse>({
    url: '/users/register',
    method: 'POST',
    data,
  })
}

```

### <font style="color:rgb(51, 51, 51);">登录注册校验</font>
<font style="color:rgb(51, 51, 51);">页面基本校验</font>

<font style="color:rgb(51, 51, 51);">用户名非空，长度校验5-10位</font>

<font style="color:rgb(51, 51, 51);">密码非空，长度校验6-15位</font>

<font style="color:rgb(51, 51, 51);">再次输入密码，非空，长度校验6-15位</font>

**<font style="color:#DF2A3F;">创建用于提交的表单数据对象</font>**

```javascript
// 登录表单数据
const loginForm = ref<LoginParams>({
  name: '',
  password: '',
})
// 注册表单数据
const registerForm = ref({
  name: '',
  password: '',
  confirmPassword: '',
})
```

**<font style="color:#DF2A3F;">rules：配置校验规则</font>**

```javascript
const rules = {
  name: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 5, max: 10, message: '用户名必须是5-10位的字符', trigger: 'blur' },
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    {
      pattern: /^\S{6,15}$/,
      message: '密码必须是6-15位的非空字符',
      trigger: 'blur',
    },
  ],
  confirmPassword: [
    { required: true, message: '请再次输入密码', trigger: 'blur' },
    {
      pattern: /^\S{6,15}$/,
      message: '密码必须是6-15的非空字符',
      trigger: 'blur',
    },
    {
      validator: (
        _rule: unknown,
        value: string,
        callback: (error?: Error) => void
      ) => {
        if (value !== registerForm.value.password) {
          callback(new Error('两次输入密码不一致!'))
        } else {
          callback()
        }
      },
      trigger: 'blur',
    },
  ],
}
```

message: 触发提示信息

trigger: 'blur' 触发方式

+ 确保字段不为空
+ 示例：`{ required: true, message: '此字段不能为空', trigger: 'blur' }`

pattern（正则表达式校验）

+ 使用正则表达式验证字段格式
+ 示例（手机号）：`{ pattern: /^1[3-9]\d{9}$/, message: '请输入正确的手机号', trigger: 'blur' }`

min/max（长度限制）

+ 限制字段的最小 / 最大长度
+ 示例：`{ min: 6, max: 20, message: '长度在6-20个字符', trigger: 'blur' }`

email（邮箱格式校验）

+ 验证字段是否为合法邮箱
+ 示例：`{ type: 'email', message: '请输入正确的邮箱地址', trigger: 'blur' }`

validator（自定义校验函数）

+ 用于复杂逻辑校验，如两次密码一致性校验
+ 示例：

```javascript
{
  validator(rule, value, callback) {
    if (value !== this.form.password) {
      callback(new Error('两次输入的密码不一致'));
    } else {
      callback();
    }
  },
  trigger: 'blur'
}
```

len（精确长度校验）

+ 确保字段长度等于指定值
+ 示例（身份证号）：`{ len: 18, message: '请输入18位身份证号', trigger: 'blur' }`

whitespace（空白字符校验）

+ 防止字段仅包含空格
+ 示例：`{ whitespace: true, message: '内容不能仅包含空格', trigger: 'blur' }`

enum（枚举值校验）

+ 确保字段值在预定义列表中
+ 示例：`{ enum: ['apple', 'banana', 'orange'], message: '请选择水果', trigger: 'change' }`

**<font style="color:#DF2A3F;">el-form 绑定表单数据对象</font>**

+ :model="表单数据对象" 
+ :rules="校验规则 " 

```vue
<el-form
  :model="loginForm"
  :rules="rules"
  ref="loginFormRef"
  size="large"
  autocomplete="off"
  class="form"
>
```

**<font style="color:#DF2A3F;">el-form-item</font>**

+ prop="name" 绑定具体校验规则

**<font style="color:#DF2A3F;">el-input </font>**

+ v-model="loginForm.name" 绑定具表单属性

```vue
<el-form-item prop="name">
  <el-input
    v-model="loginForm.name"
    :prefix-icon="User"
    placeholder="请输入用户名"
  ></el-input>
</el-form-item>
  ... 
  (其他也要绑定prop)
```

### <font style="color:rgb(51, 51, 51);">登录注册前预校验</font>
<font style="color:rgb(51, 51, 51);">点击注册按钮，注册之前，需要先校验</font>

**<font style="color:#DF2A3F;">通过 ref 获取到 表单组件</font>**

```typescript
// 分别定义登录注册表单ref
const loginFormRef = ref(null)
const registerFormRef = ref(null)
```

**<font style="color:#DF2A3F;">注册之前进行校验</font>**

```typescript
// 登录表单提交
const handleLogin = async () => {
  console.log('handleLogin')
  // 验证规则
  if (!loginFormRef.value) return
  await loginFormRef.value.validate()
  // 调用接口逻辑等
  ......
}
```

### 登录表单逻辑
+ 引入路由和用户状态管理
+ 定义表单数据和提交方法
+ 添加表单验证
+ 实现登录接口调用和登录成功后的处理逻辑（存储信息、跳转页面）

```typescript
// 登录表单提交
const handleLogin = async () => {
  console.log('handleLogin')
  // 验证规则
  if (!loginFormRef.value) return
  await loginFormRef.value.validate()

  try {
    console.log('loginForm', loginForm.value)
    // 调用登录接口
    const response = await login(loginForm.value)
    console.log('response', response.data)

    if (response.data.code === 200) {
      // 存储用户信息和token
      userStore.setUserInfo(response.data.data)
      userStore.setToken(response.data.token)

      ElMessage.success(response.data.message)
      // 登录成功跳转到地图页面
      router.push('/map')
    }
  } catch (error) {
    console.error('登录失败', error)
  }
}
```

### <font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">注册表单逻辑</font>
+ 调用注册接口并处理响应
+ 注册成功后自动切换到登录页面并清空表单

```typescript
// 注册表单提交
const handleRegister = async () => {
  // 验证
  if (!registerFormRef.value) return
  await registerFormRef.value.validate()

  try {
    // 调用注册接口
    const response = await register({
      name: registerForm.value.name,
      password: registerForm.value.password,
    })

    if (response.data.code === 200) {
      ElMessage.success(response.data.message)
      // 注册成功切换到登录页面
      toggleisLogin()
      // 清空注册表单
      registerForm.value = {
        name: '',
        password: '',
        confirmPassword: '',
      }
    }
  } catch (error) {
    console.error('注册失败', error)
  }
}
```

### 绑定表单和事件
`src/views/auth/LoginPage.vue`的模板部分：

+ 为输入框添加了`v-model`双向绑定
+ 为登录和注册按钮添加了点击事件，分别绑定`handleLogin`和`handleRegister`方法

```html
<el-form
  :model="loginForm"
  :rules="rules"
  ref="loginFormRef"
  size="large"
  autocomplete="off"
  class="form"
  >
  ......
  <el-form-item>
    <el-button @click="handleLogin" class="form-btn" type="primary" auto-insert-space >
      登录
    </el-button>
  </el-form-item>
  <el-form-item class="form-row">
    还没账号？
    <el-link type="info" :underline="false" @click="toggleisLogin()">
      点击注册 →
    </el-link>
  </el-form-item>
</el-form>
```

### 添加路由守卫
修改`src/router/index.ts`，添加路由守卫控制访问权限：

+ 添加了全局路由守卫，控制页面访问权限
+ 未登录用户访问需要登录的页面时，自动跳转到登录页
+ 已登录用户访问登录页时，自动跳转到地图首页

```typescript
// 路由守卫 - 在每次路由跳转前执行
router.beforeEach((to, from, next) => {
  // 获取用户状态管理实例
  const userStore = useUserStore()

  // 判断目标路由是否需要登录
  const needLogin = to.path !== '/login'

  if (needLogin && !userStore.isLogin()) {
    // 需要登录但未登录，跳转到登录页
    next('/login')
  } else if (to.path === '/login' && userStore.isLogin()) {
    // 已登录但访问登录页，跳转到地图页
    next('/map')
  } else if (to.matched.some((record) => record.meta.requiresAdmin)) {
    // 访问需要管理员权限的页面
    if (userStore.isAdmin()) {
      // 是管理员，正常访问
      next()
    } else {
      // 不是管理员，提示无权限并跳转到地图页
      ElMessage.error('无权限访问该页面')
      next('/map')
    }
  } else {
    // 其他情况，正常访问
    next()
  }
})
```

### <font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">后端配置跨域</font>
在 `WebConfig` 类中重写 `addCorsMappings` 方法，添加 CORS 配置，允许指定的前端域名请求：

```javascript
package com.example.fire_hydrant_management.config;
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Bean
    public TokenInterceptor tokenInterceptor() {
        return new TokenInterceptor();
    }

    // 配置CORS
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // 允许所有路径
                .allowedOrigins("http://localhost:5173/") // 允许的前端域名（替换为前端实际域名）
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS") // 允许的请求方法
                .allowedHeaders("*") // 允许的请求头
                .allowCredentials(true) // 允许携带Cookie
                .maxAge(3600); // 预检请求的有效期（秒）
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截所有请求，排除登录和注册接口
        registry.addInterceptor(tokenInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/users/login", "/users/register");
    }
}
```



# 个人中心页面
## 前端页面结构
### 页面预览
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756898450684-55793eee-cf30-4919-af5f-9c5b1f04cf41.png)

### 用户信息菜单
功能实现

+ 基本资料：展示编辑用户信息，按 ID 查询修改
+ 退出登录：清空用户信息（token 等）跳转到登录界面

userStore

```typescript
// 清除用户信息（退出登录）
const clearUserInfo = () => {
  userInfo.value = null
  token.value = ''
}
```

```vue
<script setup lang="ts">
  import { computed } from 'vue'
  import { useRoute } from 'vue-router'
  import { useRouter } from 'vue-router'
  import { useUserStore } from '@/stores/index'
  import { User } from '@element-plus/icons-vue'
  const userStore = useUserStore()
  const route = useRoute() // 获取当前路由信息
  const router = useRouter() // 用于编程式导航
  // 计算属性：应该激活的顶级菜单项
  const activeMenu = computed(() => {
    const path = route.path
    if (path.includes('/map')) {
      return '/map'
    } else if (path.includes('/dashboard')) {
      return '/dashboard'
    } else if (path.includes('/user')) {
      return '/user'
    } else {
      return path
    }
  })
  // 退出登录
  const logout = () => {
    userStore.clearUserInfo() // 清空用户信息
    // 跳转到登录页面
    router.push('/login')
  }
  const toInfo = () => {
    router.push('/user/info')
  }
  const toRepwd = () => {
    router.push('/user/repassword')
  }
</script>
<template>
  <header class="header">
    <!-- logo -->
    <div class="header-logo">
      <img src="../assets/logo.png" alt="" />
      <span class="logo-text">市政消防栓管理系统</span>
      <span class="logo-version">0.0.1</span>
    </div>
    <!-- 菜单栏 -->
    <div class="header-nav">
      <el-menu mode="horizontal" :default-active="activeMenu" router>
        <el-menu-item index="/map">首页</el-menu-item>
        <el-menu-item index="/dashboard">控制台</el-menu-item>
        <!-- 主题开关（示例：控制深色模式） -->
        <!-- <div class="header-actions">
        <theme-toggle></theme-toggle>
      </div> -->
        <el-dropdown>
          <div class="user-info">
            <div class="user-icon">
              <el-icon color="#fff" :size="24"><User /></el-icon>
            </div>
            <div class="user-name">
              <p>{{ userStore.userInfo?.name }}</p>
            </div>
          </div>
          <template #dropdown>
            <el-dropdown-menu>
              <el-dropdown-item @click="toInfo()">基本资料</el-dropdown-item>
              <el-dropdown-item @click="toRepwd()">重置密码</el-dropdown-item>
              <el-dropdown-item @click="logout()">退出登录</el-dropdown-item>
            </el-dropdown-menu>
          </template>
        </el-dropdown>
      </el-menu>
    </div>
  </header>
</template>

<style>
  .header {
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid #ebeef5;
    position: relative;
    z-index: 10;
  }

  .header-logo {
    display: flex;
    align-items: center;
  }

  .header-logo img {
    width: 40px;
    margin-right: 10px;
  }

  .header-logo .logo-text {
    font-size: 18px;
    font-weight: bold;
    color: #409eff;
  }

  .header-logo .logo-version {
    margin-left: 8px;
    font-size: 12px;
    color: #999;
  }

  /* 导航栏 */
  .header-nav {
    margin-right: 10px;
    width: 350px;
  }
  .el-dropdown {
    display: flex;
    align-items: center;
    cursor: pointer;
    margin-left: 10px;
  }
  .el-dropdown .user-info {
    display: flex;
    align-items: center;
  }
  .el-dropdown .user-icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background-color: #409eff;
    margin-right: 8px;
    }

.el-dropdown .user-icon .el-icon {
  /* 居中 */
  height: 100%;
  width: 100%;
}
.el-dropdown .user-name {
  font-size: 14px;
  color: #333;
  font-weight: bold;
}
</style>

```

### 表单校验
```typescript
// 用户信息数据对象
const userInfo = reactive({
  id: 0,
  name: '',
  sex: '',
  birthDate: '',
  department: '',
  telephone: '',
  email: '',
  role: '',
})

// 表单验证规则
const rules = {
  name: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    {
      min: 5,
      max: 10,
      message: '用户名长度在 5 到 10 个字符',
      trigger: 'blur',
    },
  ],
  sex: [], // 性别字段为可选
  birthDate: [], // 出生日期字段为可选
  department: [], // 部门字段为可选
  telephone: [
    // 电话号码格式验证（如果填写了的话）
    {
      pattern: /^1[3-9]\d{9}$/,
      message: '请输入正确的电话号码',
      trigger: 'blur',
    },
  ],
  email: [
    // 邮箱格式验证（如果填写了的话）
    {
      type: 'email' as const,
      message: '请输入正确的邮箱格式',
      trigger: 'blur',
    },
  ],
}
```

### 表单结构
绑定表单、校验规则

```html
<div class="user-info-container">
  <!-- 用户信息卡片 -->
  <el-card title="用户信息编辑" class="user-card">
    <!-- 用户信息表单 -->
    <el-form
      ref="userFormRef"
      :model="userInfo"
      :rules="rules"
      label-width="120px"
      class="user-form"
      >
      <!-- 用户名输入框 -->
      <el-form-item label="用户名" prop="name">
        <el-input v-model="userInfo.name" placeholder="请输入用户名" />
      </el-form-item>

      <!-- 性别选择框 -->
      <el-form-item label="性别" prop="sex">
        <el-radio-group v-model="userInfo.sex">
          <el-radio label="男">男</el-radio>
          <el-radio label="女">女</el-radio>
        </el-radio-group>
      </el-form-item>

      <!-- 出生日期选择器 -->
      <el-form-item label="出生日期" prop="birthDate">
        <el-date-picker
          v-model="userInfo.birthDate"
          type="date"
          placeholder="选择出生日期"
          value-format="YYYY-MM-DD"
          />
      </el-form-item>

      <!-- 部门输入框 -->
      <el-form-item label="部门" prop="department">
        <el-input v-model="userInfo.department" placeholder="请输入部门" />
      </el-form-item>

      <!-- 电话输入框 -->
      <el-form-item label="电话" prop="telephone">
        <el-input v-model="userInfo.telephone" placeholder="请输入电话号码" />
      </el-form-item>

      <!-- 邮箱输入框 -->
      <el-form-item label="邮箱" prop="email">
        <el-input
          v-model="userInfo.email"
          type="email"
          placeholder="请输入邮箱"
          />
      </el-form-item>

      <!-- 操作按钮 -->
      <el-form-item>
        <el-button type="primary" @click="handleSubmit">提交更新</el-button>
        <el-button @click="handleReset">重置</el-button>
      </el-form-item>
    </el-form>
  </el-card>
</div>
```

## 后端接口
### controller
```java
// 按ID查询用户
@GetMapping("/{id}")
public Map<String, Object> getUserById(@PathVariable Integer id) {
    Map<String, Object> result = new HashMap<>();
    try {
        Users user = usersService.getUserById(id);
        if (user != null) {
            result.put("code", 200);
            result.put("message", "查询成功");
            result.put("data", user);
        } else {
            result.put("code", 404);
            result.put("message", "用户不存在");
        }
    } catch (Exception e) {
        result.put("code", 500);
        result.put("message", "查询失败：" + e.getMessage());
    }
    return result;
}

// 编辑用户信息（PUT请求）
    @PutMapping("/update")
    public Map<String, Object> updateUser(@RequestBody Users user) {
        Map<String, Object> result = new HashMap<>();
        try {
            boolean success = usersService.updateUser(user);
            if (success) {
                result.put("code", 200);
                result.put("message", "更新成功");
            } else {
                result.put("code", 404);
                result.put("message", "用户不存在");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "更新失败：" + e.getMessage());
        }
        return result;
    }
```

### Service
```java
public interface UsersService extends IService<Users> {
    // 注册接口;
    // 登录接口
    boolean updateUser(Users user); // 编辑用户
    Users getUserById(Integer id); // 按ID查询用户
    // 删除用户
}

```

### ServiceImpl
```java
// 删除用户（根据ID）
@Override
public boolean deleteUser(Integer id) {
    // 先检查用户是否存在
    if (baseMapper.selectById(id) == null) {
        return false;
    }
    return baseMapper.deleteById(id) > 0;
}

// 按ID查询用户
@Override
public Users getUserById(Integer id) {
    return baseMapper.selectById(id);
}
```

## 接口测试
### <font style="color:#01B2BC;">更新用户信息接口</font>
**请求方法**：PUT

**请求路径**：`/users/update`

**请求头**：`Authorization: Bearer {token}`（登录后获取的 JWT 令牌）

**参数类型**：Request Body（JSON）

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| id | Integer | 用户 ID（唯一标识） | 是 |
| name | String | 用户名（可选，需唯一） | 否 |
| password | String | 密码（可选） | 否 |
| sex | String | 性别（可选） | 否 |
| birthDate | Date | 出生日期（可选） | 否 |
| department | String | 部门（可选） | 否 |
| telephone | String | 电话（可选） | 否 |
| email | String | 邮箱（可选） | 否 |


**示例请求参数**：

```json
{
  "id": 1,
  "password": "654321",
  "telephone": "13800138000"
}
```

**示例返回值**：

+ 成功（用户存在）：
+ 失败（用户不存在）：

```json
{
  "code": 200,
  "message": "更新成功"
}
{
  "code": 404,
  "message": "用户不存在"
}
```

### <font style="color:#01B2BC;">按 ID 查询用户接口</font>
**请求方法**：GET

**请求路径**：`/users/{id}`

**请求头**：`Authorization: Bearer {token}`

**参数类型**：路径参数

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| id | Integer | 要查询的用户 ID | 是 |


**示例请求路径**：`/users/1`

**示例返回值**：

+ 成功（用户存在）：

```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "id": 1,
    "name": "testUser",
    "sex": "男",
    "birthDate": "1990-01-01",
    "department": "技术部",
    "telephone": "13800138000",
    "email": "test@example.com",
    "role": "USER"
  }
}
```

+ 失败（用户不存在）

```json
{
  "code": 404,
  "message": "用户不存在"
}
```

## 前端逻辑实现
### 封装用户相关 API
```typescript
import request from '@/utils/request'

// 用户信息类型
export interface User {
  id: number
  name: string
  password?: string
  sex: string | null
  birthDate: string | null
  department: string | null
  telephone: string | null
  email: string | null
}

// 按ID查询用户
export const getUserById = (id: number) => {
  return request<{
    code: number
    data: User
    message: string
  }>({
    url: `/users/${id}`,
    method: 'GET',
  })
}

// 更新用户信息
export const updateUser = (data: User) => {
  return request<{
    code: number
    message: string
  }>({
    url: '/users/update',
    method: 'PUT',
    data,
  })
}

```

### 获取用户信息逻辑
```typescript
// 获取当前用户ID的方法
const getUserId = () => {
  // 从用户状态中获取用户ID，如果未登录则返回默认值1
  return userStore.userInfo?.id || 1
}

// 根据ID获取用户信息
const getUserInfo = async () => {
  try {
    const userId = getUserId()
    const response = await getUserById(userId)
    if (response.data.code === 200) {
      const data = response.data.data
      // 处理日期格式，转换为YYYY-MM-DD
      if (data.birthDate) {
        const date = new Date(data.birthDate)
        data.birthDate = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`
      }
      Object.assign(userInfo, data)
    } else {
      ElMessage.error('获取用户信息失败：' + response.data.message)
    }
  } catch (error) {
    console.error('获取用户信息出错：', error)
    ElMessage.error('获取用户信息失败，请稍后重试')
  }
}
```

### 更新用户信息逻辑
```java
// 提交更新用户信息
const handleSubmit = async () => {
  if (!userFormRef.value) return
  try {
    await userFormRef.value.validate()

    // 准备提交的数据（不包含role字段）
    const submitData = { ...userInfo }
    const response = await updateUser(submitData)
    if (response.data.code === 200) {
      ElMessage.success('用户信息更新成功')
    } else {
      ElMessage.error('更新失败：' + response.data.message)
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      // 表单验证失败
      if (error.name === 'Error') {
        return
      }
    }
    console.error('更新用户信息出错：', error)
    ElMessage.error('更新用户信息失败，请稍后重试')
  }
}
```



# 控制台页面
## 前端页面结构
### 页面预览
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756891451475-d2a8b9a9-54e6-48ce-8139-349a556ee3d3.png)

### <font style="color:rgb(0, 0, 0);">路由配置</font>
```java
{
  path: '/dashboard',
  name: 'Dashboard',
  component: () => import('@/views/dashboard/DashboardPage.vue'),
  meta: { requiresAdmin: true }, // 仅管理员可访问
  redirect: '/dashboard/user',
  children: [
    // 用户信息表页面
    {
      path: '/dashboard/user',
      name: 'UserInfoTable',
      component: () => import('@/views/dashboard/children/UserInfoManage.vue'),
    },
    // 消防栓信息页面
    {
      path: '/dashboard/firehydrant',
      name: 'FireHydrantInfoTable',
      component: () =>import('@/views/dashboard/children/FireHydrantInfoTable.vue'),
    },
  ],
}
// 路由守卫 - 在每次路由跳转前执行
router.beforeEach((to, from, next) => {
  // 获取用户状态管理实例
  const userStore = useUserStore()

  // 判断目标路由是否需要登录
  const needLogin = to.path !== '/login'

  if (needLogin && !userStore.isLogin()) {
    // 需要登录但未登录，跳转到登录页
    next('/login')
  } else if (to.path === '/login' && userStore.isLogin()) {
    // 已登录但访问登录页，跳转到地图页
    next('/map')
  } else if (to.matched.some((record) => record.meta.requiresAdmin)) {
    // 访问需要管理员权限的页面
    if (userStore.isAdmin()) {
      // 是管理员，正常访问
      next()
    } else {
      // 不是管理员，提示无权限并跳转到地图页
      ElMessage.error('无权限访问该页面')
      next('/map')
    }
  } else {
    // 其他情况，正常访问
    next()
  }
})
```

### 页面结构
**<font style="color:#01B2BC;">DashboardPage.vue</font>**

```vue
<script setup lang="ts">
  const NavList = [
    {
      title: '数据管理',
      subNav: [
        { navItem: '/dashboard/user', navName: '用户信息表' },
        { navItem: '/dashboard/firehydrant', navName: '消防栓信息表' },
      ],
    },
    {
      title: '系统设置',
      subNav: [],
    },
  ]
</script>

<template>
  <div class="layout">
    <!-- 左侧导航 - 200px宽度 -->
    <div class="nav">
      <!-- 通过 props 传递数据 -->
      <navigation-component :navList="NavList"></navigation-component>
    </div>
    <!-- 右侧内容区域 - 填充剩余空间 -->
    <router-view></router-view>
  </div>
</template>

<style scoped>
  .layout {
    height: 100%;
    display: flex;
    background-color: #f5f5f5;
  }

  .nav {
    width: 200px;
    background-color: #ffffff;
  }
</style>
```

## 用户信息后端接口
+ Controller：对接前端，转发请求给 Service
+ Service/ServiceImpl：处理业务逻辑，调用 Mapper 拿数据
+ Mapper：数据访问入口，继承`BaseMapper`可直接用基础方法
+ XML：只在需要自定义 SQL（复杂操作）时才用

### 分页查询注意事项
```xml
<!-- MyBatis-Plus Starter 包含分页插件 -->
<dependency>
  <groupId>com.baomidou</groupId>
  <artifactId>mybatis-plus-boot-starter</artifactId>
  <version>3.5.3.1</version> <!-- 版本需与项目兼容 -->
</dependency>
```

**<font style="color:#01B2BC;background-color:rgb(249, 250, 251);">分页插件注册</font>**

`fire_hydrant_management/config/MyBatisPlusConfig.java`

```java
@Configuration
public class MyBatisPlusConfig {
    // 注册分页插件
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 添加分页插件（指定数据库类型）
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.POSTGRE_SQL));
        return interceptor;
    }
}
```

数据库类型（如`DbType.POSTGRE_SQL`）必须与项目实际使用的数据库（此处为 PostgreSQL）匹配

否则会因分页语法差异（如 MySQL 用`LIMIT`，PostgreSQL 用`LIMIT/OFFSET`）导致 SQL 错误

**<font style="color:#01B2BC;">定义分页参数</font>**

前端需传递分页参数（页码`pageNum`、每页条数`pageSize`）

后端在 Controller 中接收并设置默认值（避免参数缺失报错）

```java
// UsersController 分页查询接口
@GetMapping("/page")
public Map<String, Object> getUserPage(
        @RequestParam(defaultValue = "1") Integer pageNum, // 默认第1页
        @RequestParam(defaultValue = "10") Integer pageSize) { // 默认每页10条
    // ...
}
```

**<font style="color:#01B2BC;">创建 Page 对象</font>**

用接收的参数实例化 MyBatis-Plus 的`Page`对象（封装分页信息）

```java
Page<Users> page = new Page<>(pageNum, pageSize); // 页码从1开始（默认）
```

**<font style="color:#01B2BC;">调用分页查询方法</font>**

在 Service 层通过`baseMapper.selectPage()`执行分页查询

需传入`Page`对象和查询条件`QueryWrapper`

```java
// UsersServiceImpl 分页查询实现
@Override
public IPage<Users> getUserPage(Page<Users> page) {
    QueryWrapper<Users> queryWrapper = new QueryWrapper<>();
    queryWrapper.orderByAsc("\"id\""); // 建议添加排序条件（避免分页结果顺序混乱）
    return baseMapper.selectPage(page, queryWrapper); // 执行分页查询
}
```

`selectPage()`方法会自动将分页参数（页码、条数）转换为对应数据库的分页 SQL

无需手动写`LIMIT`等语法。

**<font style="color:#01B2BC;">分页结果处理与返回</font>**

分页查询返回的`IPage`对象包含完整的分页信息，需提取关键数据返回给前端，方便前端渲染分页组件：

```java
// UsersController 中处理分页结果
IPage<Users> userPage = usersService.getUserPage(page);
result.put("data", userPage.getRecords()); // 当前页数据列表
result.put("total", userPage.getTotal()); // 总记录数
result.put("pages", userPage.getPages()); // 总页数
result.put("current", userPage.getCurrent()); // 当前页码
result.put("size", userPage.getSize()); // 每页实际条数
```

关键注意事项

**必须添加排序条件**

+ 分页查询时若未指定排序（如`orderByAsc/Desc`）
+ 数据库返回的记录顺序可能不稳定（尤其数据更新后），导致分页结果混乱
+ 通过`orderByAsc("\"id\"")`按 ID 排序，保证顺序稳定

**数据库字段转义**

+ 若数据库字段名是关键字（如 PostgreSQL 的`id`、`name`）
+ 排序或查询时需用双引号转义（如`"id"`），否则会触发 SQL 语法错误
+ 通过`queryWrapper.orderByAsc("\"id\"")`处理

### Controller（控制器）
对接前端，接收请求（如登录、查询用户），然后调用 Service 层的方法处理，最后把结果返回给前端

```java
@RestController // 表示该类是一个 RESTful 控制器
@RequestMapping("/users") // 定义 RESTful 接口路径
public class UsersController {
    @Autowired // 自动注入
    private JwtUtils jwtUtils; // 注入JWT工具类
    @Autowired
    private UsersService usersService; // 创建 UsersService 对象
    ......
    // 编辑用户信息（PUT请求）
    @PutMapping("/update")
    public Map<String, Object> updateUser(@RequestBody Users user) {
        Map<String, Object> result = new HashMap<>();
        try {
            boolean success = usersService.updateUser(user);
            if (success) {
                result.put("code", 200);
                result.put("message", "更新成功");
            } else {
                result.put("code", 404);
                result.put("message", "用户不存在");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "更新失败：" + e.getMessage());
        }
        return result;
    }

    // 删除用户（DELETE请求）
    @DeleteMapping("/delete/{id}")
    public Map<String, Object> deleteUser(@PathVariable Integer id) {
        Map<String, Object> result = new HashMap<>();
        try {
            boolean success = usersService.deleteUser(id);
            if (success) {
                result.put("code", 200);
                result.put("message", "删除成功");
            } else {
                result.put("code", 404);
                result.put("message", "用户不存在");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "删除失败：" + e.getMessage());
        }
        return result;
    }

    // 按ID查询用户
    @GetMapping("/{id}")
    public Map<String, Object> getUserById(@PathVariable Integer id) {
        Map<String, Object> result = new HashMap<>();
        try {
            Users user = usersService.getUserById(id);
            if (user != null) {
                result.put("code", 200);
                result.put("message", "查询成功");
                result.put("data", user);
            } else {
                result.put("code", 404);
                result.put("message", "用户不存在");
            }
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "查询失败：" + e.getMessage());
        }
        return result;
    }

    // 分页查询用户
    @GetMapping("/page")
    public Map<String, Object> getUserPage(
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        Map<String, Object> result = new HashMap<>();
        try {
            Page<Users> page = new Page<>(pageNum, pageSize);
            IPage<Users> userPage = usersService.getUserPage(page);
            result.put("code", 200);
            result.put("message", "查询成功");
            result.put("data", userPage.getRecords()); // 当前页数据
            result.put("total", userPage.getTotal()); // 总条数
            result.put("pages", userPage.getPages()); // 总页数
            result.put("current", userPage.getCurrent()); // 当前页码
            result.put("size", userPage.getSize()); // 每页条数
        } catch (Exception e) {
            result.put("code", 500);
            result.put("message", "分页查询失败：" + e.getMessage());
        }
        return result;
    }
}

```

### Service（服务接口）
`ervice`是接口，定义了业务逻辑的 “规范”（比如必须有登录、注册功能）

```java
public interface UsersService extends IService<Users> {
    // 注册接口
    boolean register(Users user);
    // 登录接口
    Users login(String name, String password);

    boolean updateUser(Users user); // 编辑用户
    boolean deleteUser(Integer id); // 删除用户
    Users getUserById(Integer id); // 按ID查询用户
    IPage<Users> getUserPage(Page<Users> page); // 分页查询用户
}
```

### ServiceImpl（服务实现类）
`ServiceImpl`是实现类，真正实现业务逻辑（比如登录时判断用户名密码是否正确）

并调用 Mapper 层获取数据

比如`UsersService`接口定义了`login`方法，`UsersServiceImpl`实现了这个方法

先通过`Mapper`查询数据库中是否有匹配的用户名和密码，再返回结果

```java
@Service
// // UserMapper 是 MyBatis 的 Mapper 接口（负责数据库交互），User 是实体类（对应数据库表）
public class UsersServiceImpl extends ServiceImpl<UsersMapper, Users> implements UsersService {
    // 注册接口
    // 登录接口
    // 编辑用户（根据ID更新）
    @Override
    public boolean updateUser(Users user) {
        // 先检查用户是否存在
        if (baseMapper.selectById(user.getId()) == null) {
            return false;
        }
        return baseMapper.updateById(user) > 0;
    }

    // 删除用户（根据ID）
    @Override
    public boolean deleteUser(Integer id) {
        // 先检查用户是否存在
        if (baseMapper.selectById(id) == null) {
            return false;
        }
        return baseMapper.deleteById(id) > 0;
    }

    // 按ID查询用户
    @Override
    public Users getUserById(Integer id) {
        return baseMapper.selectById(id);
    }

    // 分页查询用户
    @Override
    public IPage<Users> getUserPage(Page<Users> page) {
        // 无条件分页查询（可根据需求添加查询条件）
        // 添加排序条件：按 id 升序（或按 updateTime 降序）
        QueryWrapper<Users> queryWrapper = new QueryWrapper<>();
        queryWrapper.orderByAsc("\"id\""); // 按 id 升序（推荐，id 唯一且自增，顺序稳定）
        return baseMapper.selectPage(page,queryWrapper);
    }
}
```

### Mapper（数据访问接口）
负责直接和数据库打交道，定义 “如何获取数据” 的方法

关键在于：

+ MyBatis-Plus 提供了一个`BaseMapper`接口
+ 里面已经写好了最常用的增删改查方法（比如`selectById`、`insert`、`updateById`等）
+ 如果`Mapper`（比如`UsersMapper`）继承了`BaseMapper<Users>`，就自动拥有了这些方法
+ 不用自己再定义

### XML 映射文件
当`BaseMapper`提供的基础方法不够用（比如复杂的多表查询、自定义条件查询）时

需要自己在`Mapper`接口中定义方法，然后在 XML 文件中写具体的 SQL 语句

比如代码中的`login`和`register`方法

`BaseMapper`没有现成的 “根据用户名和密码查询”“注册时固定角色为 USER” 的方法

所以需要在`UsersMapper`中定义这两个方法，再在`UsersMapper.xml`中写对应的 SQL



因为 MyBatis-Plus 的`BaseMapper`已经帮写好了基础 CRUD（增删改查）的方法，比如：

+ 查询：`selectById`（根据 ID 查）、`selectList`（查列表）
+ 新增：`insert`（新增一条数据）
+ 更新：`updateById`（根据 ID 更新）
+ 删除：`deleteById`（根据 ID 删除）

当 Service 层的方法只需要这些基础操作时，直接调用`BaseMapper`的现成方法即可

:::color4
**<font style="color:#01B2BC;">无需自己在</font>**`**<font style="color:#01B2BC;">Mapper</font>**`**<font style="color:#01B2BC;">中定义方法，也不用写 XML</font>**

:::

比如代码中的`getUserById`方法：

`ServiceImpl`中直接调用`baseMapper.selectById(id)`

`baseMapper`就是继承的`BaseMapper`），而`UsersMapper`不需要额外定义这个方法

也不用 XML 写 SQL，因为`BaseMapper`已经实现了

## 接口测试
### <font style="color:#01B2BC;">更新用户信息接口</font>
**请求方法**：PUT

**请求路径**：`/users/update`

**请求头**：`Authorization: Bearer {token}`（登录后获取的 JWT 令牌）

**参数类型**：Request Body（JSON）

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| id | Integer | 用户 ID（唯一标识） | 是 |
| name | String | 用户名（可选，需唯一） | 否 |
| password | String | 密码（可选） | 否 |
| sex | String | 性别（可选） | 否 |
| birthDate | Date | 出生日期（可选） | 否 |
| department | String | 部门（可选） | 否 |
| telephone | String | 电话（可选） | 否 |
| email | String | 邮箱（可选） | 否 |


**示例请求参数**：

```json
{
  "id": 1,
  "password": "654321",
  "telephone": "13800138000"
}
```

**示例返回值**：

+ 成功（用户存在）：
+ 失败（用户不存在）：

```json
{
  "code": 200,
  "message": "更新成功"
}
{
  "code": 404,
  "message": "用户不存在"
}
```

### <font style="color:#01B2BC;">删除用户接口</font>
**请求方法**：DELETE

**请求路径**：`/users/delete/{id}`

**请求头**：`Authorization: Bearer {token}`

**参数类型**：路径参数

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| id | Integer | 要删除的用户 ID | 是 |


**示例请求路径**：`/users/delete/1`

**示例返回值**：

+ 成功（用户存在）：
+ 失败（用户不存在）：

```json
{
  "code": 200,
  "message": "删除成功"
}
{
  "code": 404,
  "message": "用户不存在"
}
```

### <font style="color:#01B2BC;">按 ID 查询用户接口</font>
**请求方法**：GET

**请求路径**：`/users/{id}`

**请求头**：`Authorization: Bearer {token}`

**参数类型**：路径参数

**参数说明**：

| **字段名** | **类型** | **说明** | **是否必填** |
| :--- | :--- | :--- | :--- |
| id | Integer | 要查询的用户 ID | 是 |


**示例请求路径**：`/users/1`

**示例返回值**：

+ 成功（用户存在）：

```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "id": 1,
    "name": "testUser",
    "sex": "男",
    "birthDate": "1990-01-01",
    "department": "技术部",
    "telephone": "13800138000",
    "email": "test@example.com",
    "role": "USER"
  }
}
```

+ 失败（用户不存在）

```json
{
  "code": 404,
  "message": "用户不存在"
}
```

### <font style="color:#01B2BC;">分页查询用户接口</font>
**请求方法**：GET

**请求路径**：`/users/page`

**请求头**：`Authorization: Bearer {token}`

**参数类型**：请求参数（Query String）

**参数说明**：

| **字段名** | **类型** | **说明** | **默认值** | **是否必填** |
| :--- | :--- | :--- | :--- | :--- |
| pageNum | Integer | 页码 | 1 | 否 |
| pageSize | Integer | 每页条数 | 10 | 否 |


+ **示例请求路径**：`/users/page?pageNum=1&pageSize=5`
+ **示例返回值**：

```json
{
    "total": 10,
    "current": 1,
    "code": 200,
    "pages": 2,
    "data": [
        {
            "id": 1,
            "name": "test01",
            "sex": "男",
            "birthDate": "2001-03-31T16:00:00.000+00:00",
            "department": "技术部",
            "telephone": "13800138000",
            "email": "test@example.com",
            "role": "ADMIN"
        },
        {
            "id": 12,
            "name": "test03",
            "sex": null,
            "birthDate": null,
            "department": null,
            "telephone": null,
            "email": null,
            "role": "USER"
        },
        {......}
    ],
    "size": 5,
    "message": "查询成功"
}
```



## 通用表格组件
`<font style="color:rgba(0, 0, 0, 0.85);">src/components/TableComponent.vue</font>`

+ 动态渲染表格列（基于传入的列配置）
+ 支持搜索过滤（基于指定字段匹配关键字）
+ 分页功能（页码切换、每页条数调整）
+ 编辑 / 删除操作按钮（触发对应事件供父组件处理）

### 定义类型与 Props
定义`TableColumn`接口（列配置：标题`label`、字段`prop`、宽度`width`）

通过`defineProps`接收父组件传入的参数：

+ `data`：表格数据（泛型`T[]`，支持任意结构数据）
+ `columns`：列配置（`TableColumn[]`）
+ `totalUsers`：总数据量（用于分页）
+ `searchKeys`：支持搜索的字段列表（用于过滤数据）

```typescript
// 定义表格列配置类型
interface TableColumn {
  label: string // 列标题
  prop: string // 对应数据字段
  width?: string | number // 列宽度（可选）
}
// Props定义
const props = defineProps({
  data: { type: Array as PropType<T[]>, required: true },
  columns: { type: Array as PropType<TableColumn[]>, required: true },
  totalUsers: { type: Number, default: 0 },
  searchKeys: { type: Array as PropType<string[]>, default: () => [] }
});
```

### 响应式变量与计算属性
`ref`分页相关变量（`currentPage`当前页、`pageSize`每页条数）搜索关键字（`search`）

`computed`实现`filterTableData`：

+ 根据`search`关键字和`searchKeys`过滤数据（不区分大小写）

```typescript
const currentPage = ref(1);
const pageSize = ref(10);
const search = ref('');
// 过滤数据
const filterTableData = computed(() => {
  if (!search.value) return props.data;
  return props.data.filter(item => 
    props.searchKeys.some(key => {
      const value = item[key];
      return value && value.toString().toLowerCase().includes(search.value.toLowerCase());
    })
                          );
});
```

### <font style="background-color:rgb(249, 250, 251);">事件处理</font>
通过`defineEmits`定义事件：`edit`（编辑）、`delete`（删除）、`page-change`（分页变化）

实现操作按钮点击逻辑：编辑 / 删除按钮触发对应事件，传递索引和行数据

分页变化时触发`page-change`，通知父组件更新数据

```typescript
const emit = defineEmits<{
  (e: 'edit', index: number, row: T): void;
  (e: 'delete', index: number, row: T): void;
  (e: 'page-change', page: number, pageSize: number): void;
}>();
// 编辑事件
const handleEdit = (index: number, row: T) => emit('edit', index, row);
// 分页变化
const handleSizeChange = (val: number) => {
  currentPage.value = 1;
  emit('page-change', currentPage.value, val);
};
```

### 模板渲染
用`el-table`展示`filterTableData`，通过`v-for`动态渲染`columns`定义的列

最后一列固定为 操作列：头部放搜索框（绑定`search`），内容放编辑 / 删除按钮

底部用`el-pagination`实现分页，绑定`currentPage`、`pageSize`和分页事件

```html
<el-table :data="filterTableData">
  <el-table-column 
    v-for="(col, index) in columns" 
    :key="index" 
    :label="col.label" 
    :prop="col.prop" 
    />
    <el-table-column align="center">
      <template #header>
        <el-input v-model="search" placeholder="输入进行搜索" />
      </template>
      <template #default="scope">
        <el-button @click="handleEdit(scope.$index, scope.row)">编辑</el-button>
        <el-button type="danger" @click="handleDelete(scope.$index, scope.row)">删除</el-button>
      </template>
    </el-table-column>
</el-table>
<el-pagination
  v-model:current-page="currentPage"
  v-model:page-size="pageSize"
  :total="props.totalUsers"
  @size-change="handleSizeChange"
  @current-change="handleCurrentChange"
  />
```

### 完整代码
```html
<script lang="ts" setup generic="T extends Record<string, any>">
import { computed, ref, defineProps, defineEmits } from 'vue'
import type { PropType } from 'vue'

// 当前页码和每页显示数量
const currentPage = ref(1)
const pageSize = ref(10)

// 定义表格列配置类型
interface TableColumn {
  label: string // 列标题
  prop: string // 对应数据字段
  width?: string | number // 列宽度（可选）
}

// 定义组件 props
const props = defineProps({
  // 表格数据
  data: {
    type: Array as PropType<T[]>,
    required: true,
  },
  // 列配置
  columns: {
    type: Array as PropType<TableColumn[]>,
    required: true,
  },
  // 总用户数（用于分页）
  totalUsers: {
    type: Number,
    default: 0,
  },
  // 搜索关键字列表
  searchKeys: {
    type: Array as PropType<string[]>,
    default: () => [],
  },
})

// 定义组件事件
const emit = defineEmits<{
  (e: 'edit', index: number, row: T): void // 编辑事件
  (e: 'delete', index: number, row: T): void // 删除事件
  (e: 'page-change', page: number, pageSize: number): void // 分页变化事件
}>()

// 搜索关键字
const search = ref('')

// 过滤表格数据
const filterTableData = computed(() => {
  // 如果没有搜索关键字，返回所有数据
  if (!search.value) {
    return props.data
  }

  // 根据搜索关键字过滤数据
  return props.data.filter((item) =>
    props.searchKeys.some((key) => {
      const value = item[key]
      // 检查字段值是否包含搜索关键字（不区分大小写）
      return (
        value &&
        value.toString().toLowerCase().includes(search.value.toLowerCase())
      )
    })
  )
})

// 处理编辑事件
const handleEdit = (index: number, row: T) => {
  emit('edit', index, row)
}

// 处理删除事件
const handleDelete = (index: number, row: T) => {
  emit('delete', index, row)
}

// 处理每页显示数量变化
const handleSizeChange = (val: number) => {
  currentPage.value = 1 // 重置到第一页
  emit('page-change', currentPage.value, val)
}

// 处理当前页变化
const handleCurrentChange = (val: number) => {
  currentPage.value = val
  emit('page-change', val, pageSize.value)
}
</script>

<template>
  <div class="content">
    <!-- 标题 -->
    <div class="title">用户信息表</div>
    <div class="table-wrapper">
      <!-- Element Plus 表格组件 -->
      <el-table :data="filterTableData" class="table">
        <!-- 动态生成表格列 -->
        <el-table-column
          v-for="(col, index) in columns"
          :key="index"
          :label="col.label"
          :prop="col.prop"
          :width="col.width"
        />
        <!-- 操作列 -->
        <el-table-column align="center">
          <!-- 表头搜索框 -->
          <template #header>
            <el-input
              v-model="search"
              size="small"
              placeholder="输入进行搜索"
            />
          </template>
          <!-- 操作按钮 -->
          <template #default="scope">
            <el-button
              size="small"
              @click="handleEdit(scope.$index, scope.row)"
            >
              编辑
            </el-button>
            <el-button
              size="small"
              type="danger"
              @click="handleDelete(scope.$index, scope.row)"
            >
              删除
            </el-button>
          </template>
        </el-table-column>
      </el-table>
      <!-- 分页组件 -->
      <div class="page">
        <div class="demo-pagination-block">
          <el-pagination
            v-model:current-page="currentPage"
            v-model:page-size="pageSize"
            :page-sizes="[5, 10]"
            :pager-count="5"
            layout="total, sizes, prev, pager, next, jumper"
            :total="props.totalUsers"
            @size-change="handleSizeChange"
            @current-change="handleCurrentChange"
          />
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
/* 内容容器样式 */
.content {
  flex: 1;
  padding: 20px;
  margin: 20px;
  background-color: #ffffff;
  border: 1px solid #ebeef5;
}

/* 标题样式 */
.content .title {
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 20px;
  border-bottom: 1px solid #ebeef5;
  padding-bottom: 20px;
}

/* 表格容器样式 */
.table-wrapper {
  position: relative;
  border: 1px solid #ebeef5;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
}

/* 分页样式 */
.page {
  position: absolute;
  bottom: -70px;
  right: 20px;
  margin-top: 20px;
  text-align: right;
}
</style>
```

## 用户信息管理逻辑
UserinfoManage.vue

+ 加载并展示用户数据（姓名、权限、性别等信息）
+ 处理用户的编辑（打开表单对话框、验证、提交更新）和删除（调用 API 删除并刷新数据）
+ 处理分页逻辑（根据页码和每页条数加载数据）

### 封装相关用户 API
`api/user.ts`

```typescript
import request from '@/utils/request'


// 分页查询参数类型
export interface PageQueryParams {
  pageNum: string | number
  pageSize: string | number
}

// 分页查询响应类型
export interface PageResponse {
  total: number
  current: number
  code: number
  pages: number
  data: User[]
  size: number
  message: string
}

// 用户信息类型
export interface User {
  id: number
  name: string
  password?: string
  sex: string | null
  birthDate: string | null
  department: string | null
  telephone: string | null
  email: string | null
}

// 分页查询用户
export const getUserPage = (params: PageQueryParams) => {
  return request<PageResponse>({
    url: '/users/page',
    method: 'GET',
    params,
  })
}

// 按ID查询用户
export const getUserById = (id: number) => {
  return request<{
    code: number
    data: User
    message: string
  }>({
    url: `/users/${id}`,
    method: 'GET',
  })
}

// 按ID删除用户
export const deleteUser = (id: number) => {
  return request<{
    code: number
    message: string
  }>({
    url: `/users/delete/${id}`,
    method: 'DELETE',
  })
}

// 更新用户信息
export const updateUser = (data: User) => {
  return request<{
    code: number
    message: string
  }>({
    url: '/users/update',
    method: 'PUT',
    data,
  })
}
```

### 定义数据类型与依赖
+ 定义`User`接口（用户数据结构：`id`、`name`、`sex`等）
+ 导入 API 方法（`getUserPage`分页获取用户、`deleteUser`删除用户等）

```typescript
interface User {
  id: number;
  name: string;
  sex: string | null;
  birthDate: string | null;
  // 其他字段...
}
import { getUserPage, deleteUser } from '@/api/user';
import { ref, onMounted } from 'vue';
import { ElMessage } from 'element-plus';
```

### 初始化数据与加载逻辑
+ 用`ref`定义用户数据（`userData`）、总条数（`totalUsers`）
+ 分页参数（`currentPage`、`pageSize`）。
+ 实现`fetchUserData`函数：调用`getUserPage` API 获取分页数据，处理日期格式（展示为 “xxxx 年 - xx 月 - xx 日”），并更新响应式变量
+ 页面挂载时（`onMounted`）调用`fetchUserData`加载初始数据

```typescript
const userData = ref<User[]>([]);
const totalUsers = ref(0);
const currentPage = ref(1);
const pageSize = ref(10);

const fetchUserData = async (page = 1, size = 10) => {
  try {
    const response = await getUserPage({ pageNum: page, pageSize: size });
    totalUsers.value = response.data.total;
    userData.value = response.data.data.map(user => {
      if (user.birthDate) {
        const date = new Date(user.birthDate);
        user.birthDate = `${date.getFullYear()}年-${(date.getMonth() + 1).toString().padStart(2, '0')}月-${date.getDate().toString().padStart(2, '0')}日`;
      }
      return user;
    });
  } catch (error) {
    console.error('获取用户数据失败', error);
  }
};

onMounted(() => fetchUserData());
```

### 编辑与删除逻辑
+ 编辑：点击表格的编辑按钮时，调用`getUserById`获取用户详情，填充到`editForm`（编辑表单数据），并打开对话框（`dialogVisible`设为`true`）
+ 提交表单时调用`updateUser` API，成功后刷新数据并关闭对话框
+ 删除：点击 “删除” 按钮时，调用`deleteUser` API，成功后刷新当前页数据

```typescript
// 编辑表单数据
const editForm = reactive({ id: 0, name: '', /* 其他字段... */ });
const dialogVisible = ref(false);

// 处理编辑事件
const handleEditUser = async (index: number, row: User) => {
  const response = await getUserById(row.id);
  Object.assign(editForm, response.data.data);
  // 处理编辑表单的日期格式（转为YYYY-MM-DD）
  if (editForm.birthDate) {
    const date = new Date(editForm.birthDate);
    editForm.birthDate = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
  }
  dialogVisible.value = true;
};

// 提交编辑表单
const submitEditForm = async () => {
  // 验证表单后调用updateUser API
  const response = await updateUser(editForm);
  if (response.data.code === 200) {
    ElMessage.success('更新成功');
    dialogVisible.value = false;
    fetchUserData(currentPage.value, pageSize.value); // 刷新数据
  }
};

// 处理删除事件
const handleDeleteUser = async (index: number, row: User) => {
  await deleteUser(row.id);
  fetchUserData(currentPage.value, pageSize.value); // 刷新数据
};
```

### <font style="background-color:rgb(249, 250, 251);">表格配置与事件绑定</font>
+ 定义`userColumns`（用户表格的列配置），指定每列的标题和对应字段
+ 使用`table-component`组件，传入`userData`、`userColumns`、`totalUsers`等 props
+ 绑定`edit`、`delete`、`page-change`事件到对应的处理函数

```vue
<table-component
  :data="userData"
  :columns="userColumns"
  :totalUsers="totalUsers"
  :searchKeys="['name', 'sex', 'birthDate', 'department', 'telephone', 'email']"
  @edit="handleEditUser"
  @delete="handleDeleteUser"
  @page-change="handlePageChange"
></table-component>
```

### 完整代码
```vue
<script setup lang="ts">
// 定义用户数据类型
interface User {
  id: number
  name: string
  sex: string | null
  birthDate: string | null
  department: string | null
  telephone: string | null
  email: string | null
  role?: string
}

// 导入所需的API方法和组件
import { getUserPage, deleteUser, getUserById, updateUser } from '@/api/user'
import { ref, onMounted, reactive } from 'vue'
import { ElMessage } from 'element-plus'
import type { FormRules } from 'element-plus'

// 用户数据和分页相关变量
const userData = ref<User[]>([]) // 用户数据列表
const totalUsers = ref(0) // 总用户数
const currentPage = ref(1) // 当前页码
const pageSize = ref(10) // 每页显示数量

// 编辑表单相关变量
const dialogVisible = ref(false) // 控制编辑对话框显示/隐藏
const editFormRef = ref() // 编辑表单引用

// 编辑表单数据
const editForm = reactive({
  id: 0,
  name: '',
  sex: '',
  birthDate: '',
  department: '',
  telephone: '',
  email: '',
  role: '',
})

// 编辑表单验证规则
const editRules = reactive<FormRules>({
  name: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    {
      min: 2,
      max: 20,
      message: '用户名长度在 2 到 20 个字符',
      trigger: 'blur',
    },
  ],
  sex: [], // 性别字段为可选
  birthDate: [], // 出生日期字段为可选
  department: [], // 部门字段为可选
  telephone: [
    // 电话号码格式验证（如果填写了的话）
    {
      pattern: /^1[3-9]\d{9}$/,
      message: '请输入正确的电话号码',
      trigger: 'blur',
    },
  ],
  email: [
    // 邮箱格式验证（如果填写了的话）
    {
      type: 'email' as const,
      message: '请输入正确的邮箱格式',
      trigger: 'blur',
    },
  ],
})

// 获取用户数据函数
const fetchUserData = async (page = 1, size = 10) => {
  try {
    // 调用API获取用户分页数据
    const response = await getUserPage({ pageNum: page, pageSize: size })
    totalUsers.value = response.data.total // 设置总用户数
    userData.value = response.data.data // 设置用户数据列表
    currentPage.value = page // 设置当前页码
    pageSize.value = size // 设置每页显示数量

    // 处理日期格式
    userData.value.forEach((user) => {
      if (user.birthDate) {
        // 格式化为xxxx-xx-xx
        const date = new Date(user.birthDate)
        user.birthDate = `${date.getFullYear()}年-${(date.getMonth() + 1).toString().padStart(2, '0')}月-${date.getDate().toString().padStart(2, '0')}日`
      }
    })
  } catch (error) {
    console.error('获取用户数据失败', error)
  }
}

// 删除用户函数
const deleteUserById = async (id: number) => {
  try {
    await deleteUser(id)
    console.log('删除用户成功')
    // 删除后刷新当前页数据
    fetchUserData(currentPage.value, pageSize.value)
  } catch (error) {
    console.error('删除用户失败', error)
  }
}

// 页面挂载时获取用户数据
onMounted(() => {
  fetchUserData()
})

// 表格列配置
const userColumns = [
  { label: '用户名', prop: 'name' },
  { label: '权限', prop: 'role' },
  { label: '性别', prop: 'sex' },
  { label: '生日', prop: 'birthDate' },
  { label: '部门', prop: 'department' },
  { label: '电话', prop: 'telephone' },
  { label: '邮箱', prop: 'email' },
]

// 处理编辑事件
const handleEditUser = async (index: number, row: User) => {
  try {
    // 获取用户详细信息
    const response = await getUserById(row.id)
    if (response.data.code === 200) {
      Object.assign(editForm, response.data.data)
      // 处理日期格式
      if (editForm.birthDate) {
        const date = new Date(editForm.birthDate)
        editForm.birthDate = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`
      }
      dialogVisible.value = true
    } else {
      ElMessage.error('获取用户信息失败：' + response.data.message)
    }
  } catch (error) {
    console.error('获取用户信息出错：', error)
    ElMessage.error('获取用户信息失败，请稍后重试')
  }
}

// 处理删除事件
const handleDeleteUser = (index: number, row: User) => {
  console.log('删除用户:', index, row)
  console.log(row.id)
  deleteUserById(row.id)
}

// 处理分页变化
const handlePageChange = (page: number, size: number) => {
  fetchUserData(page, size)
}

// 提交编辑表单
const submitEditForm = async () => {
  if (!editFormRef.value) return
  try {
    await editFormRef.value.validate()

    // 准备提交的数据
    const submitData = { ...editForm }

    const response = await updateUser(submitData)
    if (response.data.code === 200) {
      ElMessage.success('用户信息更新成功')
      dialogVisible.value = false
      // 刷新当前页数据，保持数据顺序
      fetchUserData(currentPage.value, pageSize.value)
    } else {
      ElMessage.error('更新失败：' + response.data.message)
    }
  } catch (error) {
    console.error('更新用户信息出错：', error)
    ElMessage.error('更新用户信息失败，请稍后重试')
  }
}

// 重置表单
const resetEditForm = () => {
  if (editFormRef.value) {
    editFormRef.value.resetFields()
  }
}
</script>

<template>
  <!-- 用户信息表格组件 -->
  <table-component
    :data="userData"
    :columns="userColumns"
    :totalUsers="totalUsers"
    :searchKeys="[
      'name',
      'sex',
      'birthDate',
      'department',
      'telephone',
      'email',
    ]"
    @edit="handleEditUser"
    @delete="handleDeleteUser"
    @page-change="handlePageChange"
  ></table-component>

  <!-- 编辑用户对话框 -->
  <el-dialog v-model="dialogVisible" title="编辑用户信息" width="500px">
    <el-form
      ref="editFormRef"
      :model="editForm"
      :rules="editRules"
      label-width="80px"
    >
      <!-- 用户名输入框 -->
      <el-form-item label="用户名" prop="name">
        <el-input v-model="editForm.name" placeholder="请输入用户名" />
      </el-form-item>

      <!-- 性别选择框 -->
      <el-form-item label="性别" prop="sex">
        <el-radio-group v-model="editForm.sex">
          <el-radio label="男">男</el-radio>
          <el-radio label="女">女</el-radio>
        </el-radio-group>
      </el-form-item>

      <!-- 出生日期选择器 -->
      <el-form-item label="出生日期" prop="birthDate">
        <el-date-picker
          v-model="editForm.birthDate"
          type="date"
          placeholder="选择出生日期"
          value-format="YYYY-MM-DD"
          style="width: 100%"
        />
      </el-form-item>

      <!-- 部门输入框 -->
      <el-form-item label="部门" prop="department">
        <el-input v-model="editForm.department" placeholder="请输入部门" />
      </el-form-item>

      <!-- 电话输入框 -->
      <el-form-item label="电话" prop="telephone">
        <el-input v-model="editForm.telephone" placeholder="请输入电话号码" />
      </el-form-item>

      <!-- 邮箱输入框 -->
      <el-form-item label="邮箱" prop="email">
        <el-input
          v-model="editForm.email"
          type="email"
          placeholder="请输入邮箱"
        />
      </el-form-item>
    </el-form>

    <!-- 对话框底部按钮 -->
    <template #footer>
      <span class="dialog-footer">
        <el-button @click="resetEditForm">重置</el-button>
        <el-button type="primary" @click="submitEditForm">提交</el-button>
      </span>
    </template>
  </el-dialog>
</template>

<style scoped>
/* 样式作用域限制在当前组件 */
</style>
```

# 基础地图组件功能
```bash
# 安装核心库
pnpm install mapbox-gl --save
```

## pinia 管理地图状态
`<font style="color:rgb(0, 0, 0);">store/modules/mapStore.ts</font>`

<font style="color:rgb(64, 64, 64);">集中管理地图应用的所有状态</font>

+ <font style="color:rgb(64, 64, 64);">基本状态：缩放级别(zoom)、中心点(center)、样式(style)、倾斜角度(pitch)、旋转角度(bearing)</font>
+ <font style="color:rgb(64, 64, 64);">提供响应式状态管理和状态更新方法</font>

```javascript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// 地图状态管理Store
export const useMapStore = defineStore('map', () => {
  // 状态定义
  const zoom = ref(15) // 地图缩放级别
  const center = ref([117.176, 36.6786]) // 地图中心点坐标 [经度, 纬度]
  const style = ref('tianditu-vector') // 当前地图样式标识符
  const pitch = ref(0) // 地图倾斜角度
  const bearing = ref(0) // 地图旋转角度
  // 计算属性：获取完整的地图状态
  // 返回所有状态的只读副本，避免直接修改状态
  const getMapState = computed(() => ({
    zoom: zoom.value,
    center: [...center.value], // 创建数组副本，避免引用问题
    style: style.value,
    pitch: pitch.value,
    bearing: bearing.value,
    currentTiandituLayer: currentTiandituLayer.value
  }))

  // 方法定义
  // 设置地图缩放级别
  function setZoom(newZoom: number) {
    zoom.value = newZoom
  }
  // 设置地图中心点
  function setCenter(newCenter: [number, number]) {
    center.value = newCenter
  }
  // 设置地图倾斜角度
  function setPitch(newPitch: number) {
    pitch.value = newPitch
  }
  //  设置地图旋转角度
  function setBearing(newBearing: number) {
    bearing.value = newBearing
  }

  // 返回状态和方法，供组件使用
  return {
    // 状态
    zoom,
    center,
    style,
    pitch,
    bearing,
    // 计算属性
    getMapState,
    // 方法
    setZoom,
    setCenter,
    setStyle,
    setPitch,
    setBearing,
  }
})

```

## <font style="color:rgb(0, 0, 0);">配置地图令牌变量</font>
<font style="color:rgba(0, 0, 0, 0.85);">确保 </font>`**<font style="color:#DF2A3F;">.env</font>**`<font style="color:rgba(0, 0, 0, 0.85);"> 文件位于项目根目录，与 </font>`<font style="color:rgba(0, 0, 0, 0.85);">package.json</font>`<font style="color:rgba(0, 0, 0, 0.85);"> 同级</font>

<font style="color:rgba(0, 0, 0, 0.85);">Vite 要求环境变量必须以 </font>`<font style="color:rgba(0, 0, 0, 0.85);">VITE_</font>`<font style="color:rgba(0, 0, 0, 0.85);"> 为前缀</font>

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756538680011-f3eab6bc-87e5-4ebd-ab77-5aa491fc45f5.png)

<font style="color:rgb(0, 0, 0);">代码中访问方式修改</font>

```typescript
const tiandituToken = import.meta.env.VITE_TIANDITU_TOKEN
const mapboxToken = import.meta.env.VITE_MAPBOX_TOKEN
```

## <font style="color:rgb(64, 64, 64);">初始化Mapbox地图实例</font>
`<font style="color:rgb(0, 0, 0);">components/MapComponent.vue</font>`

```vue
<script lang="ts" setup>
  import { onMounted, ref, onUnmounted } from 'vue'
  import mapboxgl from 'mapbox-gl'
  import 'mapbox-gl/dist/mapbox-gl.css'
  import { useMapStore } from '@/stores/index' //导入状态管理
  // 导入环境变量（Vite项目）
  const tiandituToken = import.meta.env.VITE_TIANDITU_TOKEN
  const mapboxToken = import.meta.env.VITE_MAPBOX_TOKEN
  const mapStore = useMapStore() //使用状态管理
  const mapContainer = ref<HTMLDivElement | null>(null) //地图容器引用
  let map: mapboxgl.Map | null = null // Mapbox地图实例引用
  // 定义初始化地图的函数
  const initMap = () => {
  // 返回一个新的Mapbox地图实例
    return new mapboxgl.Map({
      container: mapContainer.value as HTMLElement, // 指定地图容器元素
      style: mapStore.style, // 指定地图样式
      center: mapStore.center, // 指定地图初始中心点 经纬度（[lng, lat]）
      zoom: mapStore.zoomLevel, // 指定地图初始缩放级别
      projection: mapStore.projection, // 指定地图投影类型
    })
  }
  onMounted(() => {
    mapboxgl.accessToken = mapboxToken //设置Mapbox访问令牌
    console.log('Mapbox Token:', mapboxToken)
    console.log('Tianditu Token:', tiandituToken)
    // 初始化单地图实例
    map = initMap()
    // 地图加载完成事件
    map.on('load', () => {
      console.log('地图加载完成')
    })
  })
  onUnmounted(() => {
    if (map) {
      map.remove() // 移除地图实例
    }
  })
</script>
<template>
  <div>
    <div ref="mapContainer" class="map-container"></div>
  </div>
</template>
<style scoped>
  .map-container {
    height: calc(100vh - 60px);
    width: 100%;
  }
</style>
```

## <font style="color:rgb(64, 64, 64);">Store 状态实时更新</font>
`<font style="color:rgb(0, 0, 0);">components/MapComponent.vue</font>`

<font style="color:rgba(0, 0, 0, 0.95);">给</font>`map`<font style="color:rgba(0, 0, 0, 0.95);">的地图对象绑定一个</font>`move`<font style="color:rgba(0, 0, 0, 0.95);">事件。当</font>`map`<font style="color:rgba(0, 0, 0, 0.95);">发生移动时，会执行相应的回调函数</font>

<font style="color:rgba(0, 0, 0, 0.95);">获取当前地图的缩放级别</font>`newZoom`<font style="color:rgba(0, 0, 0, 0.95);">、中心坐标</font>`newCenter`<font style="color:rgba(0, 0, 0, 0.95);">（并转换为数组形式）等</font>

<font style="color:rgba(0, 0, 0, 0.95);">通过状态管理工具</font>`mapStore`<font style="color:rgba(0, 0, 0, 0.95);">来更新地图的缩放级别、中心坐标、倾斜角度和旋转角度等</font>

```vue
onMounted(() => {
  mapboxgl.accessToken = mapboxToken //设置Mapbox访问令牌
  console.log('Mapbox Token:', mapboxToken)
  console.log('Tianditu Token:', tiandituToken)
  // 初始化单地图实例
  map = initMap()
  // 地图加载完成事件
  map.on('load', () => {
    console.log('地图加载完成')
  })
  map.on('error', (e) => {
    console.error('地图加载错误:', e.error)
  })
  // 监听地图移动事件, 实时更新状态管理中的地图信息
  map.on('move', () => {
    if (!map) return
    // 获取当前地图的经纬度、缩放级别和旋转角度
    const newZoom = map.getZoom()
    const newCenter = map.getCenter().toArray()
    const newPitch = map.getPitch()
    const newBearing = map.getBearing()
    // 更新状态管理中的地图信息
    mapStore.setZoomLevel(newZoom )
    mapStore.setCenter(newCenter)
    mapStore.setPitch(newPitch )
    mapStore.setBearing(newBearing )
  })
})
```

## <font style="color:rgb(64, 64, 64);">Store 基础</font>信息展示
`<font style="color:rgb(0, 0, 0);">components/MapInfo.vue</font>`

```vue
<script lang="ts" setup>
import { useMapStore } from '@/stores/index'
import { storeToRefs } from 'pinia'
import { computed } from 'vue'
const mapstore = useMapStore() // 获取store实例
const { zoomLevel, center, pitch, bearing, style, projection } =
  storeToRefs(mapstore) // 获取地图状态
// 计算属性：格式化中心点坐标显示
const formattedCenter = computed(() => {
  if (!center.value) return '无数据'
  return `经度: ${center.value[0].toFixed(4)}, 纬度: ${center.value[1].toFixed(4)}`
})
</script>
<template>
  <div class="mapinfo">
    <p>缩放级别：{{ zoomLevel }}</p>
    <p>当前经纬度：{{ formattedCenter }}</p>
    <p>倾斜角度：{{ pitch }}</p>
    <p>旋转角度：{{ bearing }}</p>
    <p>投影方式：{{ projection }}</p>
    <p>地图样式：{{ style }}</p>
  </div>
</template>
<style scoped>
.mapinfo {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(255, 255, 255, 0.8);
  padding: 10px;
  border-radius: 4px;
  font-size: 14px;
  z-index: 1;
}
</style>

```

## <font style="color:rgb(64, 64, 64);">地图页面组件</font>
`<font style="color:rgb(0, 0, 0);">src/map/MapPage.vue</font>`

```vue
<script setup lang="ts"></script>

<template>
  <div class="map-page">
    <!-- 地图 -->
    <map-component></map-component>
    <!-- 地图信息 -->
    <map-info></map-info>
  </div>
</template>

<style scoped></style>
```

# <font style="color:rgb(64, 64, 64);">加载天地图</font>
## <font style="color:rgb(64, 64, 64);">store 添加地图类型状态和方法</font>
`stores/modules/mapStore.ts`

定义 mapbox 空白样式替换原底图样式

新增地图类型状态

新增设置地图类型方法

```vue
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// 地图相关状态
export const useMapStore = defineStore('mapStore', () => {
  // 定义一个mapbox空白样式
  const blankStyle = {
    version: 8,
    name: 'BlankMap',
    sources: {},
    // 定义空白样式 ，方便替换天地图
    layers: [
      {
        id: 'background',
        type: 'background',
        paint: {
          // 'background-color': '#08294A' /* 背景颜色 */
          'background-color': 'rgba(255, 255, 255, 0)' /* 背景颜色-透明 */,
        },
      },
    ],
  }
  // 定义状态
  const zoomLevel = ref(15) // 地图缩放级别
  const center = ref<[number, number]>([117.176, 36.6786]) // 地图中心点坐标 [经度, 纬度]
  const pitch = ref(0) // 地图俯仰角度
  const bearing = ref(0) // 地图旋转角度
  const style = blankStyle // 地图样式
  const projection = ref('globe') // 地图投影方式
  ......
  // 新增地图类型状态
  const TiandituType = ref<'vector' | 'image'>('vector')
  
  // 定义方法
  // 新增设置地图类型方法
  const setTiandituType = (newTiandituType: 'vector' | 'image') => {
    TiandituType.value = newTiandituType
  }
  .......
  return {
    // 状态
    TiandituType,
    // 方法
    setTiandituType,
  }
})

```

Mapbox 的 style 参数需要一个特定的类型 **StyleSpecification**

```vue
import type { StyleSpecification } from 'mapbox-gl'

// 定义初始化地图的函数
const initMap = () => {
  // 返回一个新的Mapbox地图实例
  return new mapboxgl.Map({
    container: mapContainer.value as HTMLElement, // 指定地图容器元素
    style: mapStore.style as StyleSpecification, // 指定地图样式
    center: mapStore.center, // 指定地图初始中心点 经纬度（[lng, lat]）
    zoom: mapStore.zoomLevel, // 指定地图初始缩放级别
    projection: mapStore.projection, // 指定地图投影类型
  })
}
```

## <font style="color:rgb(64, 64, 64);"> 定义天地图URL模板</font>
`views/map/MapComponent.vue`

天地图图层类型定义：`type TiandituLayerType = 'vec' | 'cva' | 'img' | 'cia'` 

定义了一个类型别名 `TiandituLayerType`，只能是 `'vec'`、`'cva'`、`'img'` 或 `'cia'` 这几个字符串值之一

子域名列表：`const subdomains = ['0', '1', '2', '3', '4', '5', '6', '7']` 

定义了一个常量数组 `subdomains`，包含天地图的子域名列表

生成单个图层的 URL 集合函数：

`return subdomains.map((sub) => urlTemplate.replace('{s}', sub))` 

使用数组的 `map` 方法遍历子域名列表 `subdomains`，将 URL 模板中的 `{s}` 替换为每个子域名

生成包含所有子域名的 URL 数组并返回

复制 url 时不要直接复制，换行和空格符会被错误解析，直接一行，或者字符串拼接

```typescript
// 天地图图层类型定义
type TiandituLayerType = 'vec' | 'cva' | 'img' | 'cia'
type TiandituMapType = 'vector' | 'image'
const subdomains = ['0', '1', '2', '3', '4', '5', '6', '7'] // 天地图子域名列表
// 天地图矢量图层URL模板
// 生成单个图层的URL集合
const generateLayerUrls = (layerType: TiandituLayerType, token: string) => {
  // 天地图WMTS服务基础URL模板
  const urlTemplate = 
    `https://t{s}.tianditu.gov.cn/${layerType}_w/wmts?service=WMTS
    &request=GetTile
    &version=1.0.0
    &LAYER=${layerType}
    &style=default&tilematrixSet=w&TileMatrix={z}
    &TileRow={y}&TileCol={x}&format=tiles
    &tk=${token}`
  // 生成包含所有子域名的URL数组
  return subdomains.map((sub) => urlTemplate.replace('{s}', sub))
}
```

## 配置天地图图层
`views/map/MapComponent.vue`

矢量图层组配置：  
`vector` 对象表示矢量图层组，包含 `base`（底图）和 `label`（注记）两个子对象

`base` 子对象：

+ `name` ：`tdt-vector-base`，是该图层的名称。
+ `url` ：调用 `generateLayerUrls('vec', token)` 函数生成
+ `maxZoom` ：设定最大缩放级别为 18

`label` 子对象类似

+ `name` ： `tdt-vector-label`
+ `url` ： `generateLayerUrls('cva', token)` 生成

```typescript
// 天地图图层配置生成器
const createTiandituLayers = (token: string) => ({
  // 矢量图层组（底图+注记）
  vector: {
    base: {
      name: 'tdt-vector-base',
      url: generateLayerUrls('vec', token),
      maxZoom: 18,
    },
    label: {
      name: 'tdt-vector-label',
      url: generateLayerUrls('cva', token),
      maxZoom: 18,
    },
  },
  // 影像图层组（底图+注记）
  image: {
    base: {
      name: 'tdt-image-base',
      url: generateLayerUrls('img', token),
      maxZoom: 18,
    },
    label: {
      name: 'tdt-image-label',
      url: generateLayerUrls('cia', token),
      maxZoom: 18,
    },
  },
})

// 初始化天地图图层配置
const tiandituLayers = createTiandituLayers(tiandituToken)
```

## 添加天地图数据源图层
移除已存在的同名图层和数据源

添加底图数据源和图层

添加注记数据源和图层

```typescript
console.log('Tianditu Layers Config:', tiandituLayers)
// 添加天地图数据源和图层
const addTiandituSourceAndLayer = (type: TiandituMapType) => {
  if (!map) return
  try {
    console.log(`切换到天地图${type}图层`)
    const layers = tiandituLayers[type]

    // 移除已存在的同名图层和数据源
    if (map.getLayer(layers.base.name)) {
      map.removeLayer(layers.base.name)
      map.removeSource(layers.base.name)
    }
    if (map.getLayer(layers.label.name)) {
      map.removeLayer(layers.label.name)
      map.removeSource(layers.label.name)
    }

    // 添加底图数据源和图层
    map.addSource(layers.base.name, {
      type: 'raster',
      tiles: layers.base.url,
      tileSize: 256,
      maxzoom: layers.base.maxZoom,
    })
    map.addLayer({
      id: layers.base.name,
      type: 'raster',
      source: layers.base.name,
      layout: {
        visibility: 'visible',
      },
    })

    // 添加注记数据源和图层
    map.addSource(layers.label.name, {
      type: 'raster',
      tiles: layers.label.url,
      tileSize: 256,
      maxzoom: layers.label.maxZoom,
    })
    map.addLayer({
      id: layers.label.name,
      type: 'raster',
      source: layers.label.name,
      layout: {
        visibility: 'visible',
      },
    })
  } catch (error) {
    console.error('切换天地图图层时出错:', error)
  }
}
```

# 地图功能设计
## 图层切换
### 修改 store 图层类型状态
```vue
<select :value="mapStore.TiandituType" @change="setTiandituType" class="select-box">
```

创建一个`<select>`下拉选择框

`:value="mapStore.TiandituType"`：

+ 绑定`mapStore`中的`TiandituType`属性作为选择框的当前值
+ 这样可以根据地图状态管理中的值来显示当前选中的底图样式

`@change="setTiandituType"`：

+ 绑定`change`事件，当选择框的值发生变化时，调用`setTiandituType`函数进行处理

`<option value="vector">天地图矢量</option>`：

+ 定义一个选项，值为`vector`，显示文本为 “天地图矢量”

`<option value="image">天地图影像</option>`：

+ 定义另一个选项，值为`image`，显示文本为 “天地图影像”

```vue
<script lang="ts" setup>
import { ref } from 'vue'
import { useMapStore } from '@/stores/index'
import { Event } from 'mapbox-gl'
const mapStore = useMapStore()
  // 处理底图样式选择变化的函数
const setTiandituType = (event: Event) => {
  const inputElement = event.target as HTMLInputElement
  const type = inputElement.value as 'vector' | 'image' // 获取选择值并断言类型
  mapStore.setTiandituType(type) // 调用 store 方法更新地图类型
}
</script>
<template>
  <!-- 图层控制组 -->
  <div class="control-group">
    <h4>图层控制</h4>
    <div class="control-item">
      <label>底图样式:</label>
      <select
        :value="mapStore.TiandituType"
        @change="setTiandituType"
        class="select-box"
      >
        <option value="vector">天地图矢量</option>
        <option value="image">天地图影像</option>
      </select>
    </div>
  </div>
</template>

<style scoped></style>
```

### watch 监听状态修改
监听 `mapStore.TiandituType` 的变化

当 `mapStore.TiandituType` 的值发生改变时，执行回调函数

回调函数接收新的值 `newType` 作为参数，在回调函数内部，调用 `addTiandituSourceAndLayer` 函数

将新的地图类型 `newType` 传递进去，根据新的地图类型添加相应的地图数据源和图层

例如`mapStore.TiandituType` 原本是 vector 类型，被修改为 image 类型时

`addTiandituSourceAndLayer` 函数会根据 vector 这个新类型，添加新的vector数据源和图层

```vue
onMounted(() => {
  ...... //加载地图
})
onUnmounted(() => {
  if (map) {
    map.remove() // 移除地图实例
  }
})
// 监听状态变化，同步到地图实例
// 监听地图类型变化
watch(
  () => mapStore.TiandituType,
  (newType) => {
    addTiandituSourceAndLayer(newType) //值发生变化重新调用添加数据图层方法
  }
)
```

### <font style="color:rgb(0, 0, 0);">地图布局组件</font>
`<font style="color:rgb(0, 0, 0);">views/map/MapHome.vue</font>`

```vue
<script setup lang="ts"></script>

<template>
  <div class="map-page">
    <!-- 地图 -->
    <map-component></map-component>
    <!-- 地图信息 -->
    <map-info></map-info>
    <!-- 地图操作工具箱 -->
    <map-toolbar></map-toolbar>
  </div>
</template>

<style scoped></style>

```

## <font style="color:rgb(64, 64, 64);">侧边栏工具组件</font>
<font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">components/MapToolbar.vue</font>`

核心功能：提供地图控制界面

+ 视图控制：缩放、倾斜、旋转
+ 图层控制：切换天地图底图样式
+ 重置视图：预设默认定位
+ 折叠/展开功能

### <font style="color:rgb(64, 64, 64);">折叠/展开功能</font>
使用`ref`创建`collapsed`变量，用于表示工具栏的折叠状态，初始值为`false`，即展开状态

定义`toggleCollapse`函数，用于切换`collapsed`的值，从而改变工具栏的折叠或展开状态

当函数被调用时，`collapsed.value`取反

模板部分：

`<div **<font style="color:#DF2A3F;">v-if="collapsed"</font>** class="collapsed-state">`

+ 当`collapsed`为`true`（即折叠状态）时显示的内容

`<div **<font style="color:#DF2A3F;">v-else</font>** class="expanded-state">`

+ 当`collapsed`为`false`（即展开状态）时显示的内容

```vue
<script lang="ts" setup>
import { ref } from 'vue'
import { useMapStore } from '@/stores/index'
const mapStore = useMapStore()
const collapsed = ref(false) // 工具栏折叠状态
// 切换工具栏折叠状态的函数
const toggleCollapse = () => {
  collapsed.value = !collapsed.value
}
</script>
<template>
  <!-- 侧边栏容器 -->
  <div class="map-toolbox">
    <!-- 折叠状态：只显示一个按钮 -->
    <div v-if="collapsed" class="collapsed-state">
      <button @click="toggleCollapse" class="expand-btn" title="展开工具栏">
        ☰
      </button>
    </div>
    <!-- 展开状态：显示完整工具栏 -->
    <div v-else class="expanded-state">
      <!-- 工具栏内容 -->
    </div>
  </div>
</template>

<style scoped>
/* 侧边栏状态样式 */
.map-toolbox {
  position: absolute;
  top: 60px;
  left: 5px;
  height: calc(100vh - 60px);
  z-index: 10;
  transition: all 0.3s ease;
  opacity: 0.8;
}
/* 折叠状态样式 */
.collapsed-state {
  padding-top: 10px;
}
/* 折叠按钮样式 */
.collapsed-state .expand-btn {
  width: 30px;
  height: 30px;
  background-color: rgba(255, 255, 255, 0.9);
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center; /* 垂直居中 */
  justify-content: center; /* 水平居中 */
  margin-left: 5px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

/* 展开状态样式 */
.expanded-state {
  width: 250px;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.95);
  box-shadow: 2px 0 10px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  backdrop-filter: blur(5px);
  border-right: 1px solid #e0e0e0;
}
</style>
```

### <font style="color:rgb(64, 64, 64);">视图控制：缩放、倾斜、旋转</font>
防抖：通过 `debounce` 包装，50 毫秒延迟，避免滑块拖动时触发过于频繁，减少不必要的状态更新

输入值处理：

+ 接收滑块输入事件（`Event`），将事件目标转为 `HTMLInputElement` 类型以确保类型安全
+ 再获取滑块的输入值并转换为数字类型（`newPitch`），得到最新的倾斜角度值

状态更新：

+ 调用状态管理对象 `mapStore` 的 `setPitch` 方法，将处理后的最新倾斜角度值存入状态
+ 地图组件调用 watch 监听实现倾斜角度的全局状态同步

```vue
import { ref } from 'vue'
import { useMapStore } from '@/stores/index'
import { Event } from 'mapbox-gl'
// 导入lodash的防抖函数
import { debounce } from 'lodash'
const mapStore = useMapStore()
const collapsed = ref(false) // 工具栏折叠状态
// 切换工具栏折叠状态的函数
const toggleCollapse = () => {
  collapsed.value = !collapsed.value
}
// 处理缩放滑块变化的函数（明确事件类型）
const handleZoomInput = debounce((event: Event) => {
  // 将事件目标断言为 HTMLInputElement（滑块是输入框类型）
  const inputElement = event.target as HTMLInputElement
  const newZoom = Number(inputElement.value) // 获取输入值并转为数字
  mapStore.setZoomLevel(newZoom) // 调用 store 方法更新缩放级别
}, 50) // 50毫秒防抖延迟
// 处理旋转滑块变化的函数
const updateBearing = debounce((event: Event) => {
  const inputElement = event.target as HTMLInputElement
  const newBearing = Number(inputElement.value) // 获取输入值并转为数
  mapStore.setBearing(newBearing) // 调用 store 方法更新旋转角度
}, 50)
// 倾斜滑块变化的函数
const updatePitch = debounce((event: Event) => {
  const inputElement = event.target as HTMLInputElement
  const newPitch = Number(inputElement.value) // 获取输入值并转为数
  mapStore.setPitch(newPitch) // 调用 store 方法更新倾斜角度
}, 50)
```

```html

<!-- 展开状态：显示完整工具栏 -->
<div v-else class="expanded-state">
  <div class="toolbox-header">
    <h3>地图工具</h3>
    <button @click="toggleCollapse" class="collapse-btn" title="收起工具栏">
      <el-icon><Close /></el-icon>
    </button>
  </div>
  <div class="toolbox-content">
    <!-- 视图控制组 -->
    <div class="control-group">
      <h4>视图控制</h4>
      <div class="control-item">
        <label>缩放级别: {{ mapStore.zoomLevel.toFixed(2) }}</label>
        <el-slider
          :min="1"
          :max="18"
          :step="0.5"
          v-model="mapStore.zoomLevel"
          @input="updateZoom"
          />
      </div>

      <div class="control-item">
        <label>倾斜角度: {{ mapStore.pitch.toFixed(2) }}°</label>
        <el-slider
          :min="0"
          :max="60"
          :step="1"
          v-model="mapStore.pitch"
          @input="updatePitch"
          />
      </div>

      <div class="control-item">
        <label>旋转角度: {{ mapStore.bearing.toFixed(2) }}°</label>
        <el-slider
          :min="-180"
          :max="180"
          :step="1"
          v-model="mapStore.bearing"
          @input="updateBearing"
          />
      </div>
    </div>
    </div>
  </div>
</div>
</template>
<style scoped>
  /* 侧边栏状态样式 */
  .map-toolbox {
    position: absolute;
    top: 60px;
    left: 5px;
    height: calc(100vh - 60px);
    z-index: 10;
    transition: all 0.3s ease;
    opacity: 0.95;
  }
  /* 折叠状态样式 */
  .collapsed-state {
    padding-top: 10px;
  }
  /* 折叠按钮样式 */
  .collapsed-state .expand-btn {
    width: 30px;
    height: 30px;
    background-color: rgba(255, 255, 255, 0.9);
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    display: flex;
    align-items: center; /* 垂直居中 */
    justify-content: center; /* 水平居中 */
    margin-left: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  }

  /* 展开状态样式 */
  .expanded-state {
    width: 250px;
    height: 100%;
    padding: 20px;
    background-color: rgba(255, 255, 255, 0.95);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.15);
    display: flex;
    flex-direction: column;
    backdrop-filter: blur(5px);
    border-right: 1px solid #e0e0e0;
  }
  /* 工具栏头部样式 */
  .toolbox-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
  margin-bottom: 15px;
}
.toolbox-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: bold;
}
/* 折叠按钮样式 */
.toolbox-header .collapse-btn {
  width: 30px;
  height: 30px;
  color: #f7f9f7;
  background-color: #439bf5;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  text-align: center;
  justify-content: center;
}
/* 工具栏内容样式 */
.toolbox-content {
  flex: 1;
  overflow-y: auto;
}
/* 控制组样式 */
.control-group {
  margin-bottom: 20px;
}
.control-group h4 {
  margin-bottom: 10px;
  font-size: 16px;
  border-bottom: 1px solid #ccc;
  padding-bottom: 5px;
}
/* 控制项样式 */
.control-item {
  margin-bottom: 15px;
}
.control-item label {
  display: block;
  margin-bottom: 5px;
  font-size: 14px;
  color: #333;
}
/* 滑块样式 */
.control-item .el-slider {
  width: 190px;
  margin-top: 5px;
  margin-left: 10px;
}
/* 下拉框样式 */
.control-item .el-select {
  width: 200px !important;
}
</style>

```

### <font style="color:rgb(64, 64, 64);">重置视图：预设默认定位</font>
<font style="color:rgba(0, 0, 0, 0.85);">MapComponent 和 MapToolbar 属于同级组件时，推荐通过</font>**父组件作为中间桥梁**<font style="color:rgba(0, 0, 0, 0.85);">进行通信</font>

<font style="color:rgba(0, 0, 0, 0.85);">父组件 </font>`<font style="color:rgba(0, 0, 0, 0.85);">MapPage.vue</font>`

```html
<script setup lang="ts">
import { ref } from 'vue'
import MapComponent from '@/components/MapComponent.vue'

// 获取地图组件实例
const mapComponentRef = ref<InstanceType<typeof MapComponent> | null>(null)

// 处理重置地图事件
const handleResetMap = () => {
  // 调用地图组件的重置方法
  if (mapComponentRef.value) {
    mapComponentRef.value.resetMapView()
  }
}
</script>

<template>
  <div class="map-page">
    <!-- 地图 -->
    <map-component ref="mapComponentRef"></map-component>
    <!-- 地图信息 -->
    <map-info></map-info>
    <!-- 地图操作工具箱 -->
    <map-toolbar @reset-map="handleResetMap"></map-toolbar>
  </div>
</template>

<style scoped></style>

```

`mapStore.ts` 中添加初始状态定义

```typescript
  // 初始状态定义
  const initialState = {
    zoomLevel: 15, // 初始缩放级别
    center: [117.176, 36.6786] as [number, number], // 初始中心点坐标 [经度, 纬度]
    pitch: 0, // 初始倾斜角度
    bearing: 0, // 初始旋转角度
  }
```

`<font style="color:rgba(0, 0, 0, 0.85);">MapComponent.vue</font>`<font style="color:rgba(0, 0, 0, 0.85);"> 定义重置方法</font>

```typescript
// 地图实例重置方法
const resetMapView = () => {
  if (map) {
    map.flyTo({
      center: mapStore.initialState.center,
      zoom: mapStore.initialState.zoomLevel,
      pitch: mapStore.initialState.pitch,
      bearing: mapStore.initialState.bearing,
    })
  }
  console.log('地图视图已重置')
}
// 暴露方法供外部调用
defineExpose({
  addTiandituSourceAndLayer,
  resetMapView,
})
```

 `MapToolbar.vue` 中调用重置方法：

```html
<script lang="ts" setup>
import { ref, defineEmits } from 'vue'
// 定义要触发的事件
const emit = defineEmits(['reset-map'])
// 点击重置按钮时触发事件
const handleResetClick = () => {
  emit('reset-map')
}
</script>  
<template>
  <div class="control-item">
    <el-button type="primary" @click="handleResetClick"
      >重置视图</el-button>
  </div>
</template>
```

### <font style="color:rgb(64, 64, 64);">图层控制：切换天地图底图样式</font>
## 优化视图状态监听
**问题：地图操作不跟手（滚轮缩放幅度小、右键旋转需多次点击）**

地图原生交互与状态管理的更新形成了循环触发，导致操作反馈延迟或被抑制

+ 当鼠标操作地图（滚轮缩放 / 右键旋转）时，地图会触发`move`事件
+ `move`事件中会更新 store 的`zoomLevel`/`pitch`/`bearing`状态
+ 同时又监听了 store 状态变化，反过来调用`map.setZoom()`/`setPitch()`等方法

这种 "操作→更新状态→再更新地图" 的循环会抵消部分操作效果，导致不跟手

**解决循环更新问题**

区分 "用户直接操作地图" 和 "通过工具栏控制地图" 两种场景，避免循环触发更新

+ 通过`isUserInteraction`标记区分 "用户鼠标操作" 和 "工具栏控制"
+ 当用户用鼠标操作时，不执行`watch`中的`map.setXXX()`方法，避免重复设置

### <font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">修改地图状态管理（mapStore.ts）</font>
```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

// 地图相关状态
export const useMapStore = defineStore('mapStore', () => {
  // 新增：标记是否是用户直接操作地图（鼠标/手势）导致的更新
  const isUserInteraction = ref(false)
  
  // 添加fromUser参数，标记是否是用户直接操作
  const setZoomLevel = (newZoomLevel: number, fromUser = false) => {
    if (fromUser) isUserInteraction.value = true
    zoomLevel.value = newZoomLevel
    if (fromUser) {
      // 延迟重置标记，避免同步冲突
      setTimeout(() => (isUserInteraction.value = false), 0)
    }
  }
  const setPitch = (newPitch: number, fromUser = false) => {
    if (fromUser) isUserInteraction.value = true
    pitch.value = newPitch
    if (fromUser) {
      setTimeout(() => (isUserInteraction.value = false), 0)
    }
  }
})
```

### <font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">修改地图组件（MapComponent.vue）</font>
`**<font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);">src/components/MapComponent.vue</font>**`**<font style="color:rgb(0, 0, 0);background-color:rgb(249, 250, 251);"> </font>**<font style="color:rgba(0, 0, 0, 0.85);background-color:rgb(249, 250, 251);">优化事件监听和状态同步逻辑</font>

**地图move事件**中，标记更新来自**用户直接操作地图，****<font style="color:#DF2A3F;">不再触发 watch 监听</font>**

```typescript
onMounted(() => {
  // 初始化单地图实例
  ......
  // 监听地图移动事件, 实时更新状态管理中的地图信息
  map.on('move', () => {
    if (!map) return
    // 获取当前地图的经纬度、缩放级别和旋转角度
    const newZoom = map.getZoom()
    const newCenter = map.getCenter().toArray()
    const newPitch = map.getPitch()
    const newBearing = map.getBearing()
    // 更新状态管理中的地图信息
    mapStore.setZoomLevel(newZoom, true)
    mapStore.setCenter(newCenter)
    mapStore.setPitch(newPitch, true)
    mapStore.setBearing(newBearing, true)
  })
})
```

优化watch监听，通过工具栏控制地图，避免循环触发

```typescript
// 监听缩放级别变化
watch(
  () => mapStore.zoomLevel,
  (newZoom) => {
    // 只有非用户直接操作时，才通过store更新地图
    if (map && !mapStore.isUserInteraction) {
      map.setZoom(newZoom)
    }
  }
)
// 监听俯仰角变化
watch(
  () => mapStore.pitch,
  (newPitch) => {
    if (map && !mapStore.isUserInteraction) {
      map.setPitch(newPitch)
    }
  }
)
// 监听旋转角变化
watch(
  () => mapStore.bearing,
  (newBearing) => {
    if (map && !mapStore.isUserInteraction) {
      map.setBearing(newBearing)
    }
  }
)
```

<font style="color:rgb(64, 64, 64);"></font>

## 地图信息组件
<font style="color:rgb(64, 64, 64);"> </font>`<font style="color:rgb(64, 64, 64);background-color:rgb(236, 236, 236);">components/MapInfo.vue</font>`<font style="color:rgb(64, 64, 64);"></font>

**<font style="color:rgb(64, 64, 64);">核心功能</font>**<font style="color:rgb(64, 64, 64);">：显示地图当前状态信息</font>

+ <font style="color:rgb(64, 64, 64);">实时显示地图状态(中心点、缩放级别等)</font>
+ <font style="color:rgb(64, 64, 64);">提供信息复制功能</font>
+ <font style="color:rgb(64, 64, 64);">支持展开/收起显示模式</font>

**<font style="color:rgb(64, 64, 64);">关键思路</font>**<font style="color:rgb(64, 64, 64);">：</font>

+ <font style="color:rgb(64, 64, 64);">使用计算属性格式化显示信息</font>
+ <font style="color:rgb(64, 64, 64);">通过Store获取实时地图状态</font>

```vue
<script setup>
import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useMapStore } from '@/stores/index'

// 获取store实例
const store = useMapStore()

// 面板展开状态
const expanded = ref(true)
// 地图边界信息
const bounds = ref(null)

/**
 * 计算属性：格式化中心点坐标显示
 */
const formattedCenter = computed(() => {
  if (!store.center) return '无数据'
  return `经度: ${store.center[0].toFixed(4)}, 纬度: ${store.center[1].toFixed(4)}`
})

/**
 * 计算属性：简化的中心点显示（用于收起状态）
 */
const truncatedCenter = computed(() => {
  if (!store.center) return '无数据'
  return `${store.center[0].toFixed(2)}, ${store.center[1].toFixed(2)}`
})

/**
 * 计算属性：获取地图样式名称
 */
const styleName = computed(() => {
  const styleMap = {
    'tianditu-vector': '天地图矢量',
    'tianditu-satellite': '天地图影像',
    'tianditu-terrain': '天地图地形',
    'streets-v12': 'Mapbox街道',
    'satellite-streets-v12': 'Mapbox卫星街道',
    'dark-v11': 'Mapbox暗色',
    'light-v11': 'Mapbox亮色',
    'outdoors-v12': 'Mapbox户外'
  }
  return styleMap[store.style] || store.style
})

/**
 * 计算属性：格式化边界信息显示
 */
const boundsString = computed(() => {
  if (!bounds.value) return '计算中...'
  const ne = bounds.value.getNorthEast()
  const sw = bounds.value.getSouthWest()
  return `[${sw.lat.toFixed(2)},${sw.lng.toFixed(2)}] - [${ne.lat.toFixed(2)},${ne.lng.toFixed(2)}]`
})

/**
 * 切换面板展开状态
 */
function toggleExpanded() {
  expanded.value = !expanded.value
}

/**
 * 复制地图信息到剪贴板
 */
function copyInfo() {
  const info = `地图状态信息:
中心点: ${formattedCenter.value}
缩放级别: ${store.zoom.toFixed(2)}
倾斜角度: ${store.pitch}°
旋转角度: ${store.bearing}°
地图样式: ${styleName.value}
可视区域: ${boundsString.value}
`
  // 使用Clipboard API复制文本
  navigator.clipboard
    .writeText(info)
    .then(() => {
      // 可以添加Toast提示而不是alert
      alert('地图信息已复制到剪贴板')
    })
    .catch((err) => {
      console.error('复制失败:', err)
      // 降级方案：使用textarea和execCommand
      fallbackCopyText(info)
    })
}

/**
 * 复制文本的降级方案
 * @param {string} text - 要复制的文本
 */
function fallbackCopyText(text) {
  const textArea = document.createElement('textarea')
  textArea.value = text
  textArea.style.position = 'fixed'
  textArea.style.opacity = '0'
  document.body.appendChild(textArea)
  textArea.focus()
  textArea.select()

  try {
    const successful = document.execCommand('copy')
    const msg = successful ? '成功' : '失败'
    console.log('降级复制 ' + msg)
    alert(`地图信息复制${msg}`)
  } catch (err) {
    console.error('降级复制失败:', err)
    alert('复制失败，请手动复制控制台信息')
  }

  document.body.removeChild(textArea)
}

/**
 * 截图功能（示例实现）
 */
function takeScreenshot() {
  // 在实际项目中，这里应该调用Mapbox的截图API
  // 例如: map.value.takeSnapshot()
  alert('截图功能已触发！在实际应用中，这里会调用地图的截图API')
}

/**
 * 更新地图边界信息
 * 注意：这是一个模拟实现，实际项目中应该从地图实例获取真实边界
 */
function updateBounds() {
  // 模拟获取边界数据
  // 实际项目中应该使用: bounds.value = map.value.getBounds()
  setTimeout(() => {
    bounds.value = {
      getNorthEast: () => ({
        lat: store.center[1] + 0.1 / Math.pow(2, 18 - store.zoom),
        lng: store.center[0] + 0.1 / Math.pow(2, 18 - store.zoom)
      }),
      getSouthWest: () => ({
        lat: store.center[1] - 0.1 / Math.pow(2, 18 - store.zoom),
        lng: store.center[0] - 0.1 / Math.pow(2, 18 - store.zoom)
      })
    }
  }, 100)
}

// 监听中心点和缩放级别变化，更新边界信息
watch(() => [store.center, store.zoom], updateBounds, { immediate: true })

// 组件生命周期
onMounted(() => {
  console.log('地图信息组件已加载')
})

onUnmounted(() => {
  console.log('地图信息组件已卸载')
})
</script>

<template>
  <div class="map-info-panel">
    <!-- 信息面板头部 -->
    <div class="info-header">
      <h3>地图信息</h3>
      <button
        @click="toggleExpanded"
        class="toggle-btn"
        :title="expanded ? '收起信息' : '展开信息'"
      >
        {{ expanded ? '−' : '+' }}
      </button>
    </div>

    <!-- 展开状态下的详细信息 -->
    <div v-if="expanded" class="info-content">
      <!-- 中心点坐标 -->
      <div class="info-item">
        <span class="label">中心点坐标:</span>
        <span class="value">{{ formattedCenter }}</span>
      </div>

      <!-- 缩放级别 -->
      <div class="info-item">
        <span class="label">缩放级别:</span>
        <span class="value">{{ store.zoom.toFixed(2) }}</span>
      </div>

      <!-- 倾斜角度 -->
      <div class="info-item">
        <span class="label">倾斜角度:</span>
        <span class="value">{{ store.pitch }}°</span>
      </div>

      <!-- 旋转角度 -->
      <div class="info-item">
        <span class="label">旋转角度:</span>
        <span class="value">{{ store.bearing }}°</span>
      </div>

      <!-- 地图样式 -->
      <div class="info-item">
        <span class="label">地图样式:</span>
        <span class="value">{{ styleName }}</span>
      </div>

      <!-- 可视区域 -->
      <div class="info-item">
        <span class="label">可视区域:</span>
        <span class="value">{{ boundsString }}</span>
      </div>

      <!-- 操作按钮 -->
      <div class="actions">
        <button
          @click="copyInfo"
          class="action-btn"
          title="复制地图信息到剪贴板"
        >
          复制信息
        </button>
        <button
          @click="takeScreenshot"
          class="action-btn"
          title="截取当前地图视图"
        >
          截图
        </button>
      </div>
    </div>

    <!-- 收起状态下的简化信息 -->
    <div v-else class="minimized-view">
      <span>中心: {{ truncatedCenter }}</span>
      <span>缩放: {{ store.zoom.toFixed(1) }}</span>
    </div>
  </div>
</template>

<style scoped>
.map-info-panel {
  position: absolute;
  bottom: 10px;
  right: 10px;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  padding: 15px;
  min-width: 250px;
  z-index: 2;
  backdrop-filter: blur(5px);
  border: 1px solid #e0e0e0;
  max-height: 70vh;
  overflow-y: auto;
  transition: all 0.3s ease;
}

.info-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  border-bottom: 1px solid #eee;
  padding-bottom: 10px;
}

.info-header h3 {
  margin: 0;
  color: #2c3e50;
  font-size: 16px;
  font-weight: 600;
}

.toggle-btn {
  background: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 12px;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.toggle-btn:hover {
  background: #e0e0e0;
}

.info-content {
  border-top: 1px solid #eee;
  padding-top: 12px;
}

.info-item {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 14px;
  line-height: 1.4;
}

.info-item .label {
  font-weight: 600;
  color: #555;
  flex-shrink: 0;
  margin-right: 10px;
}

.info-item .value {
  color: #2c3e50;
  text-align: right;
  word-break: break-all;
  flex-grow: 1;
}

.actions {
  display: flex;
  justify-content: space-between;
  margin-top: 15px;
  padding-top: 10px;
  border-top: 1px solid #eee;
}

.action-btn {
  background: #4264fb;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  font-size: 12px;
  cursor: pointer;
  flex: 1;
  margin: 0 5px;
  transition: background-color 0.2s ease;
}

.action-btn:hover {
  background: #3250d6;
}

.minimized-view {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #666;
  padding: 5px 0;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .map-info-panel {
    bottom: 10px;
    right: 10px;
    left: 10px;
    min-width: auto;
  }

  .info-item {
    flex-direction: column;
  }

  .info-item .value {
    text-align: left;
    margin-top: 4px;
  }

  .actions {
    flex-direction: column;
    gap: 8px;
  }

  .action-btn {
    margin: 0;
  }
}
</style>

```

# GeoJSON 数据存储发布
步骤概述： 

+ 准备GeoJSON数据
+ 将GeoJSON数据导入PostGIS数据库
+ 配置GeoServer，连接PostGIS数据库，发布图层
+ 前端Mapbox GL JS加载GeoServer发布的WMS/WFS图层
+ 实现前端编辑功能，并将编辑结果通过WFS-T或自定义API传回GeoServer/PostGIS

## <font style="color:rgb(64, 64, 64);">数据准备 (PostGIS)</font>
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756348232116-3f1650e8-1ffd-4a21-9933-3982ddd1be13.png)

### 新建数据库
**基于模板新建**

右键数据库  -  创建数据库  -  输入常规信息  -  定义选项卡中选择 PostGIS 模版

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756539615706-43710365-944e-4c81-ab6f-4c5282e43c16.png)

**新建数据库  -  查询工具  -  启用PostGIS扩展**

```sql
CREATE EXTENSION postgis;
CREATE EXTENSION postgis_topology;
```

**<font style="color:#DF2A3F;">验证安装</font>**

+ <font style="color:rgb(64, 64, 64);">执行以下SQL验证PostGIS是否安装成功：</font>

```sql
SELECT PostGIS_Version();
```

**<font style="color:rgb(64, 64, 64);">执行建表 SQL</font>**

```sql
CREATE TABLE features (
    id integer NOT NULL DEFAULT nextval('features_id_seq'::regclass),
    geom geometry,
    currentstatus character varying(10),
    currentpressure double precision,
    ManufacturerNo character varying(50),
    ManagementUnit character varying(50),
    InstallationDate date,
    ManagementUserNo integer,
    PRIMARY KEY (id)
);
```

**<font style="color:rgb(64, 64, 64);">使用图形化界面创建表</font>**

**<font style="color:rgb(64, 64, 64);">创建表结构</font>**

<font style="color:rgb(64, 64, 64);">切换到 </font>**<font style="color:rgb(64, 64, 64);">列</font>**<font style="color:rgb(64, 64, 64);"> 选项卡，点击 </font>**<font style="color:rgb(64, 64, 64);">+</font>**<font style="color:rgb(64, 64, 64);"> 添加列：</font>

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757228719391-59a00a64-adac-47c5-883e-9bbe91dfdee9.png)

### <font style="color:rgb(64, 64, 64);">导入GeoJSON数据</font>
<font style="color:rgb(64, 64, 64);">由于pgAdmin4没有直接导入GeoJSON的图形化功能，需要使用以下方法：</font>

**<font style="color:#DF2A3F;">使用查询工具导入（推荐）</font>**

准备GeoJSON数据，使用PostGIS函数导入

+ <font style="color:rgb(64, 64, 64);">打开查询工具，执行以下SQL：</font>

```sql
-- 创建一个临时表来存储原始GeoJSON数据
CREATE TABLE temp_import (data jsonb);

-- 将GeoJSON文件内容复制到临时表
COPY temp_import FROM '/path/to/your/data.geojson';

-- 提取要素并插入到features表
INSERT INTO features (geom, properties)
SELECT 
    ST_GeomFromGeoJSON(feature->'geometry'),
    feature->'properties'
FROM (
  SELECT jsonb_array_elements(data->'features') AS feature 
  FROM temp_import
) AS features;

-- 清理临时表
DROP TABLE temp_import;
```

**<font style="color:#DF2A3F;">使用QGIS中转（图形化方式）</font>**

详细看[QGIS笔记](https://www.yuque.com/lingxiao-yugup/cm3baa/utpray7rgeq34yae)

链接 postgis 数据库

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756349312568-a77f12a6-bb0a-4778-be65-afa11465610d.png)![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756350060427-fe96f81d-6cc8-46b9-a2c8-5fe28c375180.png)

**<font style="color:rgb(64, 64, 64);">使用QGIS导入GeoJSON</font>**

+ <font style="color:rgb(64, 64, 64);">打开QGIS， 图层  -  添加图层  -  添加矢量图层</font>
+ <font style="color:rgb(64, 64, 64);">选择GeoJSON文件</font>
+ <font style="color:rgb(64, 64, 64);">数据库管理器  -  导入图层或文件</font>
+ <font style="color:rgb(64, 64, 64);">格式选择PostgreSQL</font>

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756349995978-74eb888f-bc5a-4dd4-bb44-989aee410985.png)

### 查看数据库
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757228845742-03b1eedb-d3d4-438c-b142-7dcca772277c.png)

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757228869039-e27b70c4-670d-4840-9af6-b10b9da35478.png)

## <font style="color:rgb(64, 64, 64);">GeoServer配置</font>
笔记[GeoServer](https://www.yuque.com/lingxiao-yugup/cm3baa/cprzxo2fe544d9v3)

### 新建工作空间
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756350298857-47557075-35c7-4d24-b8d1-c721394e48e7.png)

### 添加数据
左侧菜单栏  -  **数据存储  -  添加新的数据存储**：

数据源类型： **PostGIS  -  PostGIS 数据库**；

填写基本信息：

+ 工作区：选择创建的工作区（ fire_hydrant）；
+ 数据存储名称：自定义（ hydrants_postgis ）；

填写连接参数：

+ 主机：`localhost`；
+ 端口：`5432`；
+ 数据库：`fire_hydrant_data`（数据库名）；
+ 用户：`postgres`；
+ 密码：数据库密码；
+ 数据库模式：`public`；
+ 勾选  保存密码 ；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756350392004-e7fca174-8120-42db-8f93-66207db21e65.png)

### <font style="color:rgb(0, 0, 0);">发布 PostGIS 图层（WMS+WFS）</font>
左侧菜单栏  -   **图层  -  添加新的图层**

选择创建的 PostGIS 数据存储（ hydrants_postgis ）

下方会显示该数据存储中的表（如`features`），点击 发布；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756350525268-f8cdc4e2-5055-4760-9783-8ca38fb6c2ef.png)

在 编辑图层页面配置核心参数：

**基本信息**：

+ 图层名称：自定义（ hydrants_layer ）；
+ 标题：自定义（ 消防栓数据 ，前端显示用）；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757228996907-e261a44e-4b23-43bc-be1e-08272fe625e7.png)

**坐标系**：

+ 声明的 SRS：选择 **EPSG:4326 - WGS 84**（与 PostGIS 一致）；
+ 勾选启用原生的 SRS（确保用 PostGIS 原始坐标系）；

**边框**：点击计算，自动生成图层的地理范围（避免地图加载时范围异常）；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757229009991-da861947-8eaa-4a09-807c-dc4fb6c014cf.png)

**<font style="color:rgba(0, 0, 0, 0.85);">添加要素类型</font>**

**<font style="color:rgba(0, 0, 0, 0.85);">对应数据表属性字段</font>**

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757228975493-712fb05a-7f5a-4929-8598-3fb3ad1b0663.png)

点击保存，进入图层发布页面，继续配置：

## WFS 设置
WFS Web 要素服务，支持对地理要素的插入，更新，删除，检索和发现服务

不同于 WMS（Web 地图服务），该服务专注于要素的地理信息，而忽略其渲染信息，简化返回信息

<font style="color:rgb(25, 27, 31);">一个图层的 WFS 服务查看方法是在 Layer Preview 页面，选择 WFS 下的 </font><font style="color:rgb(9, 64, 142);">GeoJSON</font><font style="color:rgb(25, 27, 31);">（以 JSON 数据形式展现要素信息，方便解析），查看该图层的要素信息</font>

（关键：启用编辑权限）

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757058955656-b9475efd-32b1-42c3-aefd-3420055e1bf4.png)

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757058971785-d226e080-8f91-4c7b-b3a0-9d13a0faf58f.png)



![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757059063384-529fcdf8-55e8-4fe3-9728-c214ee3327fd.png)

### 验证 GeoServer 服务可用性
左侧菜单栏  -  **图层  -  图层预览**，找到发布的图层（fire_hydrant:hydrants_layer）；

在图层右侧的  **预览 **下拉框中，选择 **OpenLayers**（或GeoJSON）：

若选择 OpenLayers：会打开一个地图页面，显示数据，说明 WMS 服务正常；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756351080882-4ca298c1-10cb-4df7-bd75-173e9f6c62dd.png)

若选择 GeoJSON：会下载一个 GeoJSON 文件，包含 PostGIS 中的数据，说明 WFS 服务正常；

![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1756351058180-651af5f6-6c75-4e3c-ba57-7bb9dcb65b05.png)

# <font style="color:rgb(0, 0, 0);">GeoJSON 数据加载</font>
前端通过加载 GeoServer 的 **WFS 服务** 获取 GeoJSON 数据（支持编辑），并在 Mapbox 地图上显示

核心是通过 Axios 请求 WFS 接口，将返回的 GeoJSON 添加到 Mapbox 数据源

<font style="color:rgb(0, 0, 0);">核心思路</font>

+ GeoServer 的 WFS 接口支持通过`GetFeature`请求获取数据，返回格式指定为 GeoJSON；
+ 前端用 Axios 请求该接口，获取数据后添加到 Mapbox 的`geojson`数据源；

## 封装GeoServer WFS 服务 API
默认返回 ID 会携带图层名称，遍历`response.data.features`数组，处理每个要素的`id`属性：

+ 如果要素有`id`，将其按点号（`.`）分割成数组。
+ 如果分割后的数组长度大于 1，将`id`设置为分割后的第二个部分；否则保持原`id`不变

```typescript
import axios from 'axios'
// GeoServer基础URL
const baseURL = 'http://localhost:8085/geoserver'
// 从GeoServer加载要素数据
export const loadFeatures = async (): Promise<GeoJSON.FeatureCollection> => {
  const url = `${baseURL}/wfs`
  // WFS GetFeature请求参数
  const params = {
    service: 'WFS',
    version: '1.1.0',
    request: 'GetFeature',
    typeName: 'fire_hydrant:fire_hydrants',
    outputFormat: 'application/json',
    srsName: 'urn:ogc:def:crs:EPSG::4326',
  }
  try {
    const response = await axios.get(url, { params })
    // 遍历循环，分割id fire_hydrants.1 --> 1
    response.data.features.forEach((feature: GeoJSON.Feature) => {
      if (feature.id) {
        const idParts = String(feature.id).split('.')
        feature.id = idParts.length > 1 ? idParts[1] : feature.id
      }
    })
    return response.data
  } catch (error) {
    console.error('加载要素失败:', error)
    throw error
  }
}
```

## <font style="color:rgb(64, 64, 64);">地图加载 GeoJSON 数据显示</font>
### 导入 API
引入`@/api/geoserver`中的`loadFeatures`方法，用于从 GeoServer 服务获取地理要素数据

```typescript
import { loadFeatures } from '@/api/geoserver' //geoserver要素API
```

### 定义响应式数据：
+ 创建`geojsonData`响应式变量（类型为`GeoJSON.FeatureCollection`）
+ 初始值为含空`features`数组的要素集合，用于存储最终要渲染的地理数据

```typescript
const geojsonData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
}) // GeoJSON数据
```

### <font style="color:rgb(0, 0, 0);">地图图层与数据源清理（</font>`cleanupMapLayersAndSources`<font style="color:rgb(0, 0, 0);">）</font>
+ 避免重复添加图层 / 数据源导致冲突，在添加新数据前执行清理

```typescript
// 方法：清理地图图层和数据源方法
const cleanupMapLayersAndSources = () => {
  if (!map) return

  // 如果图层已存在则移除（必须先移除图层再移除数据源）
  if (map.getLayer('hydrants-layer')) {
    map.removeLayer('hydrants-layer')
  }

  // 如果数据源已存在则移除
  if (map.getSource('hydrants')) {
    map.removeSource('hydrants')
  }
}
```

### <font style="color:rgb(0, 0, 0);">GeoJSON 数据加载与预处理（</font>`loadGeoJSONData`<font style="color:rgb(0, 0, 0);">）</font>
异步从 GeoServer 获取数据并处理，为渲染做准备，步骤：

+ **数据请求**：通过`await loadFeatures()`异步调用 GeoServer API，获取原始地理要素数据
+ **数据预处理**：遍历原始数据的每个`feature`
    - 处理`id`：将格式如`fire_hydrants.1`的`id`按`.`分割，取后段（如`1`）作为新`id`；
    - 处理时间属性：若`feature.properties`含`InstallationDate`，移除其末尾的`Z`字符；
+ **数据存储**：将处理后的完整数据赋值给`geojsonData`响应式变量；
+ **触发渲染**：调用`addGeoJSONToMap()`方法，将处理后的数据添加到地图；

```typescript
// 方法：加载GeoJSON数据
const loadGeoJSONData = async () => {
  try {
    const data = await loadFeatures() // 从GeoServer加载数据
    // 遍历循环，分割id fire_hydrants.1 --> 1
    data.features.forEach((feature: GeoJSON.Feature) => {
      if (feature.id) {
        const idParts = String(feature.id).split('.')
        feature.id = idParts.length > 1 ? idParts[1] : feature.id
      }
      if (feature.properties?.InstallationDate) {
        // 移除末尾的 Z（如果存在）
        feature.properties.InstallationDate =
          feature.properties.InstallationDate.replace('Z', '')
      }
    })
    geojsonData.value = data
    console.log('加载GeoJSON数据成功', data)
    // 添加数据到地图
    addGeoJSONToMap()
  } catch (error) {
    console.error('加载GeoJSON数据出错:', error)
    ElMessage.error('加载数据失败，请稍后重试')
  }
}
```

### <font style="color:rgb(0, 0, 0);">地图要素渲染（</font>`addGeoJSONToMap`<font style="color:rgb(0, 0, 0);">）</font>
将`geojsonData`中的数据渲染为地图可视化要素

+ **清理旧数据**：调用`cleanupMapLayersAndSources()`，移除已有的旧图层和数据源；
+ **添加数据源**：
    - 通过`map.addSource`添加`hydrants`数据源，类型为`geojson`
    - 数据来源为`geojsonData.value`，关闭聚类（`cluster: false`）
+ **添加渲染图层**：通过`map.addLayer`添加`hydrants-layer`圆形图层，核心配置：
    - 图层类型：`circle`（圆形要素，用于表示消防栓等点要素）；
    - 关联数据源：`source: 'hydrants'`（绑定上述添加的数据源）；
+ **样式配置（**`**paint**`**）：**
    - 基础样式：圆形半径 8px，白色描边（宽度 2px）；
    - 条件颜色：根据`feature`的`currentstatus`属性匹配颜色
    - 正常：绿色`#4CAF50`、异常：黄色`#FFC107`、错误：：红色`#F44336`，默认：灰色`#9E9E9E`

```typescript
// 方法：将GeoJSON数据和图层添加到地图
const addGeoJSONToMap = () => {
  if (!map) return
  // 使用统一的清理方法
  cleanupMapLayersAndSources()
  // 添加数据源
  map.addSource('hydrants', {
    type: 'geojson',
    data: geojsonData.value,
    cluster: false,
  })
  // 添加图层
  map.addLayer({
    id: 'hydrants-layer',
    type: 'circle',
    source: 'hydrants',
    paint: {
      'circle-radius': 8,
      // 根据currentstatus属性设置不同颜色
      'circle-color': [
        'match',
        ['get', 'currentstatus'], // 获取currentstatus属性值
        'normal',
        '#4CAF50', // 正常状态 - 绿色
        'Abnormal',
        '#FFC107', // 异常状态 - 黄色
        'Error',
        '#F44336', // 错误状态 - 红色
        '#9E9E9E', // 默认颜色 - 灰色（如果属性值不在上述列表中）
      ],
      'circle-stroke-width': 2,
      'circle-stroke-color': '#fff',
    },
  })
}
```

### 完整代码
```vue
<script lang="ts" setup>
import { loadFeatures } from '@/api/geoserver' //geoserver要素API
  
const geojsonData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
}) // GeoJSON数据

// 方法：清理地图图层和数据源方法
const cleanupMapLayersAndSources = () => {
  if (!map) return

  // 如果图层已存在则移除（必须先移除图层再移除数据源）
  if (map.getLayer('hydrants-layer')) {
    map.removeLayer('hydrants-layer')
  }

  // 如果数据源已存在则移除
  if (map.getSource('hydrants')) {
    map.removeSource('hydrants')
  }
}
// 方法：加载GeoJSON数据
const loadGeoJSONData = async () => {
  try {
    const data = await loadFeatures() // 从GeoServer加载数据
    // 遍历循环，分割id fire_hydrants.1 --> 1
    data.features.forEach((feature: GeoJSON.Feature) => {
      if (feature.id) {
        const idParts = String(feature.id).split('.')
        feature.id = idParts.length > 1 ? idParts[1] : feature.id
      }
      if (feature.properties?.InstallationDate) {
        // 移除末尾的 Z（如果存在）
        feature.properties.InstallationDate =
          feature.properties.InstallationDate.replace('Z', '')
      }
    })
    geojsonData.value = data
    console.log('加载GeoJSON数据成功', data)
    // 添加数据到地图
    addGeoJSONToMap()
  } catch (error) {
    console.error('加载GeoJSON数据出错:', error)
    ElMessage.error('加载数据失败，请稍后重试')
  }
}
// 方法：将GeoJSON数据和图层添加到地图
const addGeoJSONToMap = () => {
  if (!map) return
  // 使用统一的清理方法
  cleanupMapLayersAndSources()
  // 添加数据源
  map.addSource('hydrants', {
    type: 'geojson',
    data: geojsonData.value,
    cluster: false,
  })
  // 添加图层
  map.addLayer({
    id: 'hydrants-layer',
    type: 'circle',
    source: 'hydrants',
    paint: {
      'circle-radius': 8,
      // 根据currentstatus属性设置不同颜色
      'circle-color': [
        'match',
        ['get', 'currentstatus'], // 获取currentstatus属性值
        'normal',
        '#4CAF50', // 正常状态 - 绿色
        'Abnormal',
        '#FFC107', // 异常状态 - 黄色
        'Error',
        '#F44336', // 错误状态 - 红色
        '#9E9E9E', // 默认颜色 - 灰色（如果属性值不在上述列表中）
      ],
      'circle-stroke-width': 2,
      'circle-stroke-color': '#fff',
    },
  })
}
</script>
```

### 返回结果
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757231138353-e76c300d-d7c3-496d-8315-752314e03cf2.png)

## 添加 Marker 标记
### <font style="color:rgb(0, 0, 0);">核心变量定义</font>
`markers: mapboxgl.Marker[]`：数组，用于存储所有已创建的地图标记，便于后续统一管理

`selectedFeature: ref<GeoJSON.Feature | null>`：响应式变量，存储当前被选中的地理要素

`featureLngLat: ref<[number, number] | null>`：响应式变量，存储当前选中要素的经纬度坐标

```typescript
const markers: mapboxgl.Marker[] = [] // 存储所有标记的数组
const selectedFeature = ref<GeoJSON.Feature | null>(null) // 当前选中的要素
const featureLngLat = ref<[number, number] | null>(null) // 当前要素经纬度
```

### <font style="color:rgb(0, 0, 0);">自定义标记创建（</font>`creatMarker`<font style="color:rgb(0, 0, 0);"> 方法）</font>
根据地理要素信息创建自定义样式的地图标记

**坐标处理**：

+ 针对 `MultiPoint` 类型的几何数据，提取第一个点的坐标作为标记位置
+ 从地图点击事件获取的要素是`Point`类型，直接提取点的坐标

**自定义元素**：

+ 创建 `div` 元素作为标记载体，添加 `custom-marker` 样式类
+ 并根据要素的 `currentstatus` 属性设置背景色
+ 正常：绿色 `#4CAF50`、异常：黄色 `#FFC107`、错误：红色 `#F44336`

**标记内容**：在标记上显示要素 ID（`ID:${feature.id}`）

**返回标记实例**：基于上述配置创建 `mapboxgl.Marker` 实例，设置锚点为底部，绑定坐标并添加到地图

**添加自定义属性：**通过HTML 元素的 dataset 属性，为某个元素添加一个自定义属性来存储 feature.id

```typescript
// 方法：创建单个marker标记
const creatMarker = (feature: GeoJSON.Feature): mapboxgl.Marker | null => {
  let coordinates: [number, number] | null = null // 初始化坐标变
  // 处理MultiPoint类型
  if (
    feature.geometry.type === 'MultiPoint' &&
    feature.geometry.coordinates.length > 0
  ) {
    // 使用第一个点作为标记位置
    coordinates = feature.geometry.coordinates[0] as [number, number]
  }
  // 处理Point类型
  else if (feature.geometry.type === 'Point') {
    coordinates = feature.geometry.coordinates as [number, number]
  }

  if (!coordinates) {
    console.log('无法从要素中提取坐标:', feature)
    return null
  }
  // 创建自定义HTML元素作为标记
  const markerHtml = document.createElement('div')
  markerHtml.className = 'custom-marker' // 自定义样式类
  // 根据currentStatus属性设置不同颜色
  // normal、Abnormal、Error

  markerHtml.style.backgroundColor =
    feature.properties?.currentStatus === 'Abnormal'
      ? '#FFC107'
      : feature.properties?.currentStatus === 'Error'
        ? '#F44336'
        : '#4CAF50'
  markerHtml.textContent = `ID:${feature.id} ` // 显示要素ID
  const marker = new mapboxgl.Marker({
    element: markerHtml,
    anchor: 'bottom',
  })
    .setLngLat(coordinates)
    .addTo(map as mapboxgl.Map)
  // 添加自定义属性存储feature.id，通过HTMLElement的dataset属性
  marker.getElement().dataset.featureId = String(feature.id)
  return marker
}
```

### <font style="color:rgb(0, 0, 0);">地图要素与标记管理（</font>`addGeoJSONToMap`<font style="color:rgb(0, 0, 0);"> 方法）</font>
核心功能：将处理后的 GeoJSON 数据添加到地图，同时创建并管理标记，具体流程：

**前置清理**：

+ 调用 `cleanupMapLayersAndSources` 清除旧的图层和数据源，避免冲突
+ 遍历 `markers` 数组，移除所有已添加的标记并清空数组，确保标记与数据同步

**添加数据源与图层**：

+ 向地图添加 `hydrants` 数据源
+ 添加 `hydrants-layer` 图层（代码省略部分推测为圆形图层样式配置）

**标记创建与状态统计**：

+ 遍历 `geojsonData.value.features`，仅处理 `Point` 或 `MultiPoint` 类型的要素
+ 调用 `creatMarker` 为每个有效要素创建标记，成功则添加到 `markers` 数组

**交互事件绑定**：

+ 鼠标样式：鼠标进入图层时显示指针样式（`pointer`），离开时恢复默认样式

```typescript
// 方法：将GeoJSON数据和图层添加到地图
const addGeoJSONToMap = () => {
  if (!map) return
  // 使用统一的清理方法
  cleanupMapLayersAndSources()
  // 清除markers数组中的旧标记
  if (markers.length > 0) {
    markers.forEach((marker) => marker.remove())
    markers.length = 0 // 清空数组
  }

  // 添加数据源
  map.addSource('hydrants', {
    type: 'geojson',
    data: geojsonData.value,
    cluster: false,
  })
  // 添加图层
  map.addLayer({
    id: 'hydrants-layer',
    type: 'circle',
    source: 'hydrants',
    ......
  })
  
  // 为每个要素创建并存储marker
  geojsonData.value.features.forEach((feature: GeoJSON.Feature) => {
    if (
      feature.geometry.type === 'Point' ||
      feature.geometry.type === 'MultiPoint'
    ) {
      const marker = creatMarker(feature)
      // 只有成功创建标记时才添加到数组和地图
      if (marker) {
        markers.push(marker)
      }
    }
  })
  // 改变鼠标样式
  map.on('mouseenter', 'hydrants-layer', () => {
    if (map) {
        map.getCanvas().style.cursor = 'pointer'
      }
  })

  map.on('mouseleave', 'hydrants-layer', () => {
    if (map) {
        map.getCanvas().style.cursor = ''
      }
    }
  )
}
```

### 结果展示
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757231683476-f1825b4a-d938-451b-8b4b-b0b5ec006066.png)

## <font style="color:rgb(64, 64, 64);">添加点击要素信息弹窗</font>
### <font style="color:rgb(0, 0, 0);">要素信息弹窗展示（HTML 部分）</font>
基于响应式变量动态渲染的弹窗组件：

显示条件：由 `v-if="showFeatureInfo"` 控制，为 `true` 时展示

内容组成：

+ 标题：显示当前选中要素的 `id`
+ 内容区：展示格式化后的属性（状态、压力、安装日期、管理单位、管理用户等）
+ 数据来源于 `selectedProperties`

```html
<!-- 要素信息弹窗 -->
<div class="feature-info-container" v-if="showFeatureInfo">
  <div class="info-title">
    <span class="info-title-text"
      >当前选择要素ID：{{ selectedProperties.id }}</span
    >
  </div>
  <div class="info-content">
    <span class="info-item"
      >当前状态：{{ selectedProperties.currentstatus }}</span
    >
    <span class="info-item"
      >当前压力：{{ selectedProperties.currentpressure }}</span
    >
    <span class="info-item"
      >安装日期：{{ selectedProperties.InstallationDate }}</span
    >
    <span class="info-item"
      >管理单位：{{ selectedProperties.ManagementUnit }}</span
    >
    <span class="info-item"
      >管理用户：{{ selectedProperties.ManagementUserNo }}</span
    >
  </div>
</div>
```

### <font style="color:rgb(0, 0, 0);">要素属性定义与状态存储</font>
**接口定义**：

+ `HydrantProperties` 接口规范消防栓要素核心属性（`id`、`currentstatus`、`currentpressure`等）

**响应式变量**：

+ `selectedProperties: ref<HydrantProperties>({})`：当前选中要素的格式化属性，用于弹窗展示
+ `showFeatureInfo: ref(false)`：控制要素信息对话框的显示 / 隐藏状态

```typescript
// 声明 HydrantProperties 属性信息接口（展示用）
interface HydrantProperties {
  id?: string
  currentstatus?: string
  currentpressure?: string
  ManagementUnit?: string
  ManagementUserNo?: string
  InstallationDate?: string
const selectedProperties = ref<HydrantProperties>({}) // 选中要素的属性表单
const showFeatureInfo = ref(false) // 是否显示要素信息对话框
// 方法：将GeoJSON数据和图层添加到地图
const addGeoJSONToMap = () => {
  if (!map) return
  // 使用统一的清理方法
  cleanupMapLayersAndSources()
  // 清除markers数组中的旧标记
  if (markers.length > 0) {
    markers.forEach((marker) => marker.remove())
    markers.length = 0 // 清空数组
  }
  // 添加数据源
  map.addSource('hydrants', {
    type: 'geojson',
    data: geojsonData.value,
    cluster: false,
  })
  // 添加图层
  map.addLayer({
    id: 'hydrants-layer',
    type: 'circle',
    source: 'hydrants',
    paint: {
      'circle-radius': 8,
      // 根据currentstatus属性设置不同颜色
      'circle-color': [
        'match',
        ['get', 'currentstatus'], // 获取currentstatus属性值
        'normal',
        '#4CAF50', // 正常状态 - 绿色
        'Abnormal',
        '#FFC107', // 异常状态 - 黄色
        'Error',
        '#F44336', // 错误状态 - 红色
        '#9E9E9E', // 默认颜色 - 灰色（如果属性值不在上述列表中）
      ],
      'circle-stroke-width': 2,
      'circle-stroke-color': '#fff',
    },
  })
  // 为每个要素创建并存储marker
  geojsonData.value.features.forEach((feature: GeoJSON.Feature) => {
    if (
      feature.geometry.type === 'Point' ||
      feature.geometry.type === 'MultiPoint'
    ) {
      const status = feature.properties?.currentstatus
      if (status in statusCounts) {
        statusCounts[status as keyof typeof statusCounts]++
      }
      echartsData.value = {
        normal: statusCounts.normal,
        Abnormal: statusCounts.Abnormal,
        Error: statusCounts.Error,
      }
      const marker = creatMarker(feature)
      // 只有成功创建标记时才添加到数组和地图
      if (marker) {
        markers.push(marker)
      }
    }
  })
  // 添加点击事件
  map.on('click', 'hydrants-layer', (e) => {
    handleFeatureClick(e)
  })
  // 改变鼠标样式
  map.on('mouseenter', 'hydrants-layer', () => {
    if (map) {
      // 只有在非编辑模式下才改变鼠标样式
      if (!isEditing.value) {
        map.getCanvas().style.cursor = 'pointer'
      }
    }
  })
  map.on('mouseleave', 'hydrants-layer', () => {
    if (map) {
      // 只有在非编辑模式下才恢复鼠标样式
      if (!isEditing.value) {
        map.getCanvas().style.cursor = ''
      }
    }
  })
}
```

### <font style="color:rgb(0, 0, 0);">属性映射转换（</font>`mapFeatureProperties`<font style="color:rgb(0, 0, 0);"> </font><font style="color:rgb(0, 0, 0);">方法）</font>
功能：将原始要素属性转换为适合展示的格式，核心逻辑：

状态文本转换：

+ 通过 `statusMap` 将英文状态（`normal`/`Abnormal`/`Error`）映射中文（`正常`/`异常`/`错误`）

属性整合：

+ 提取原始要素的 `id`、`currentpressure`、`InstallationDate` 等关键属性
+ 封装为 `HydrantProperties` 类型返回，用于弹窗展示

```typescript
// 映射要素属性
const mapFeatureProperties = (
  selectedFeature: GeoJSON.Feature
): HydrantProperties => {
  const properties = selectedFeature.properties
  // 根据不同properties?.currentstatus映射不同的显示值
  const statusMap: { [key: string]: string } = {
    normal: '正常',
    Abnormal: '异常',
    Error: '错误',
  }

  const displayStatus = properties?.currentstatus
    ? statusMap[properties.currentstatus] || properties.currentstatus
    : undefined

  return {
    id: String(selectedFeature.id || ''),
    currentstatus: displayStatus,
    currentpressure: properties?.currentpressure,
    ManagementUnit: properties?.ManagementUnit,
    InstallationDate: properties?.InstallationDate,
    ManagementUserNo: properties?.ManagementUserNo,
  }
}
```

### <font style="color:rgb(0, 0, 0);">获取要素点击信息（</font>`GetClickFeature`<font style="color:rgb(0, 0, 0);"> 方法）</font>
处理地图要素的点击事件，实现选中逻辑与弹窗触发：

+ 要素获取：从点击事件 `e` 中提取选中的要素（`e.features[0]`），赋值给 `selectedFeature`
+ 属性格式化：调用 `mapFeatureProperties` 将原始属性转换为 `selectedProperties`，供弹窗使用
+ 地图定位：获取要素坐标（`Point` 类型的 `coordinates`）,通过 `map.flyTo` 让地图平滑飞到该位置

```typescript
// 获取点击的要素
const GetClickFeature = async (e: mapboxgl.MapMouseEvent) => {
  const features = e.features
  if (features && features.length > 0) {
    selectedFeature.value = features[0] as GeoJSON.Feature
    selectedProperties.value = mapFeatureProperties(selectedFeature.value)
    // 修复类型推断过深的问题
    const geometry = selectedFeature.value?.geometry
    if (geometry && geometry.type === 'Point') {
      selectedFeatureCoord.value = geometry.coordinates as [number, number]
    }
    map?.flyTo({
      center: selectedFeatureCoord.value as [number, number],
      zoom: 17,
    })
  }
}
```

### 要素信息弹窗
```typescript
const showFeatureInfo = ref(false) // 是否显示要素信息对话框
```

```html
<!-- 要素信息弹窗 -->
<div class="feature-info-container" v-if="showFeatureInfo">
  <div class="info-title">
    <span class="info-title-text"
      >当前选择要素ID：{{ selectedProperties.id }}</span
                                             >
  </div>
  <div class="info-content">
    <span class="info-item"
      >当前状态：{{ selectedProperties.currentStatus }}</span
                                                    >
    <span class="info-item"
      >当前压力：{{ selectedProperties.currentPressure }}</span
                                                      >
    <span class="info-item"
      >安装日期：{{ selectedProperties.installationDate }}</span
                                                       >
    <span class="info-item"
      >管理单位：{{ selectedProperties.managementUnit }}</span
                                                     >
    <span class="info-item"
      >管理用户：{{ selectedProperties.managementUserNo }}</span
                                                       >
  </div>
</div>
```

```typescript
// 处理 点击要素查看信息
const handleFeatureClickForInfo = (e: mapboxgl.MapMouseEvent) => {
  GetClickFeature(e) // 获取点击的要素
  console.log('当前点击要素:', selectedFeature.value)
  console.log('当前点击要素属性:', selectedProperties.value)
}
```

```typescript
// 监听hydrants-layer图层点击事件
map.on('click', 'hydrants-layer', (e) => {
  // 监听默认模式下的点击事件
  if (!isUpdatingMode.value && !isDeletingMode.value) {
    handleFeatureClickForInfo(e)
    showFeatureInfo.value = true // 打开信息弹窗
  }
  // 监听更新模式下的点击事件
  if (isUpdatingMode.value) {
    handleFeatureClickForUpdate(e)
  }
  // 监听删除模式下的点击事件
  if (isDeletingMode.value) {
    handleFeatureClickForDelete(e)
  }
})
// 改变鼠标样式
map.on('mouseenter', 'hydrants-layer', () => {
  if (map) {
    // 只有在非编辑模式下才改变鼠标样式
    if (!isAddingMode.value) {
      map.getCanvas().style.cursor = 'pointer'
    }
  }
})

map.on('mouseleave', 'hydrants-layer', () => {
  if (map) {
    // 只有在非编辑模式下才恢复鼠标样式
    if (!isAddingMode.value) {
      map.getCanvas().style.cursor = ''
    }
  }
})
```

### 结果展示
![](https://cdn.nlark.com/yuque/0/2025/png/56143711/1757234489740-05883696-9653-4b7c-ab71-e3fe73b27bf0.png)



# GeoJSON 数据编辑（WFS-T)
<font style="color:rgba(0, 0, 0, 0.85);">整合模式控制、表单交互、地图操作、数据隔离等核心能力，支持要素的添加、删除、更新与保存</font>

关于WFS-T，查看笔记[https://www.yuque.com/lingxiao-yugup/cm3baa/cprzxo2fe544d9v3](https://www.yuque.com/lingxiao-yugup/cm3baa/cprzxo2fe544d9v3)

## 编辑功能设计
```typescript
const isEditingMode = ref(false) // 是否处于编辑模式
const isAddingMode = ref(false) // 是否处于添加模式
const isUpdatingMode = ref(false) // 是否处于更新模式
const isDeletingMode = ref(false) // 是否处于删除模式
```

### 编辑功能结构
```html
<!-- 编辑功能 -->
    <div class="edit-controls">
      <!-- 1. 全局编辑模式开关：根据 isEditing 切换按钮文本和类型 -->
      <el-button
        :type="isEditingMode ? 'danger' : 'primary'"
        @click="handleEditClick()"
        >{{ isEditingMode ? '结束编辑' : '开始编辑' }}</el-button
      >
      <!-- 2. 编辑模式下显示的工具按钮（添加/删除/更新/保存） -->
      <div v-if="isEditingMode" class="edit-tool">
        <!-- 要素添加按钮：根据 isAddingMode 切换文本和类型 -->
        <el-button
          :type="isAddingMode ? 'danger' : 'primary'"
          @click="handleAddClick()"
          >{{ isAddingMode ? '结束添加' : '添加要素' }}</el-button
        >

        <!-- 要素更新按钮：根据 isUpdatingMode 切换文本和类型 -->
        <el-button
          :type="isUpdatingMode ? 'danger' : 'primary'"
          @click="handleUpdateClick()"
          >{{ isUpdatingMode ? '结束更新' : '更新要素' }}</el-button
        >
        <!-- 要素删除按钮：根据 isDeletingMode 切换文本和类型 -->
        <el-button
          :type="isDeletingMode ? 'danger' : 'primary'"
          @click="handleDeleteClick()"
          >{{ isDeletingMode ? '结束删除' : '删除要素' }}</el-button
        >

        <!-- 保存更改按钮：触发数据持久化 -->
        <el-button type="primary" @click="saveChanges(currentOptions)"
          >保存更改</el-button
        >
      </div>
    </div>
```

### <font style="color:rgb(0, 0, 0);">鼠标样式控制</font>
<font style="color:rgba(0, 0, 0, 0.85);">通过 </font>`<font style="color:rgba(0, 0, 0, 0.85);">updateMapCursor</font>`<font style="color:rgba(0, 0, 0, 0.85);"> 方法，根据当前模式动态切换地图鼠标光标</font>

```typescript
// 更新鼠标样式
const updateMapCursor = () => {
  if (!map) return
  if (isEditingMode.value) {
    map.getCanvas().style.cursor = 'default' //箭头
    if (isAddingMode.value) {
      map.getCanvas().style.cursor = 'crosshair' // 添加十字准星
    }
    if (isDeletingMode.value) {
      map.getCanvas().style.cursor = 'default' // 删除，箭头样式
    }
    if (isUpdatingMode.value) {
      map.getCanvas().style.cursor = '' // 更新
    }
  } else {
    map.getCanvas().style.cursor = '' // 默认
  }

```

### 编辑模式切换逻辑
定义点击事件处理函数：异步函数 `handleEditClick`，用于处理 “开始编辑” 按钮的点击事件

计算新的编辑状态：

+ `const newEditingState = !isEditingMode.value` 
+ 根据当前的编辑状态 `isEditingMode.value` 计算新的编辑状态
+ 如果当前是编辑模式，则新状态为非编辑模式；反之亦然

启动编辑模式处理：

+ 当 `newEditingState` 为 `true` 时，即启动编辑模式
+ 显示成功提示信息，并将 `isEditingMode.value` 设置为新状态

非启动编辑模式处理：

+ 当 `newEditingState` 为 `false` 时，即关闭编辑模式
+ 会根据当前处于的不同子模式（添加、更新、删除）进行不同处理：

添加模式处理：

+ 如果 `isAddingMode.value` 为 `true`，表示当前处于添加模式
+ 弹出确认框询问用户是否确认退出

更新模式处理

删除模式处理：

其他情况处理：

+ 若不处于上述三种子模式，直接设置新的编辑状态

更新鼠标样式：无论编辑状态如何改变，最后都会执行 `updateMapCursor()` 来更新鼠标样式

```typescript
// 事件：点击"开始编辑"按钮
const handleEditClick = async () => {
  const newEditingState = !isEditingMode.value // 计算新的编辑状态
  if (newEditingState) {
    ElMessage.success('当前状态: 启动编辑模式')
    isEditingMode.value = newEditingState // 设置新状态
  } else {
    // 如果正在添加模式，询问是否取消添加
    if (isAddingMode.value) {
      try {
        await ElMessageBox.confirm(
          '当前正在添加要素，退出将丢失未保存的更改，是否确认退出？',
          '确认退出',
          {
            confirmButtonText: '确认',
            cancelButtonText: '取消',
            type: 'warning',
          }
        )
        console.log('点击了确认退出按钮')
        isAddingMode.value = false // 停止添加模式
        resetEditData() // 停止添加模式
        isEditingMode.value = newEditingState // 设置新状态
      } catch {
        console.log('点击了取消按钮')
        // 用户取消操作，不退出编辑模式，保持原有状态
        return
      }
      // 如果正在更新模式，询问是否取消添加
    } else if (isUpdatingMode.value) {
      try {
        await ElMessageBox.confirm(
          '当前正在更新要素，退出将丢失未保存的更改，是否确认退出？',
          '确认退出',
          {
            confirmButtonText: '确认',
            cancelButtonText: '取消',
            type: 'warning',
          }
        )
        console.log('点击了确认退出按钮')
        isUpdatingMode.value = false
        resetEditData() // 停止更新模式
        isEditingMode.value = newEditingState // 设置新状态
      } catch {
        console.log('点击了取消按钮')
        // 用户取消操作，不退出编辑模式，保持原有状态
        return
      }
      // 如果正在删除模式，询问是否取消添加
    } else if (isDeletingMode.value) {
      try {
        await ElMessageBox.confirm(
          '当前正在删除要素，退出将丢失未保存的更改，是否确认退出？',
          '确认退出',
          {
            confirmButtonText: '确认',
            cancelButtonText: '取消',
            type: 'warning',
          }
        )
        console.log('点击了确认退出按钮')
        isDeletingMode.value = false
        resetEditData() // 停止删除模式
        isEditingMode.value = newEditingState // 设置新状态
      } catch {
        console.log('点击了取消按钮')
        // 用户取消操作，不退出编辑模式，保持原有状态
        return
      }
    } else {
      isEditingMode.value = newEditingState // 设置新状态
      ElMessage.error('当前状态: 关闭编辑模式')
    }
  }
  updateMapCursor() // 更新鼠标样式
}
```

### 还原编辑数据
```typescript
const resetEditData = () => {
  // 1. 清空添加模式下的临时要素数据
  if (tempGeoJSONData.value.features.length > 0) {
    tempGeoJSONData.value.features = []
  }
  // 2. 清空添加时存储的临时坐标
  tempCoordinates.value = null
  // 3. 关闭可能未关闭的要素编辑弹窗
  if (showEditFeatureDialog.value) {
    showEditFeatureDialog.value = false
  }
  // 4. 清空更新模式下的要素选中状态
  selectedFeature.value = null
  selectedFeatureCoord.value = null
  selectedProperties.value = {} as HydrantProperties // 按接口类型重置空对象
  // 5. 重新加载原始数据，确保地图显示与正式数据源一致
  loadGeoJSONData()
}
```

### <font style="color:rgb(0, 0, 0);">点击添加按钮（</font>`handleAddClick`<font style="color:rgb(0, 0, 0);">）</font>
`stopUpdateMode ()和 stopDeleteMode ()`：

调用这两个函数，停止更新模式和删除模式，以确保只处于添加模式

```typescript
// 事件：点击添加按钮
const handleAddClick = () => {
  isAddingMode.value = !isAddingMode.value // 切换添加状态
  if (isAddingMode.value) {
    ElMessage.primary('请在地图上点击添加新点')
    currentOptions.value = 'insert'
    isUpdatingMode.value = false
    isDeletingMode.value = false
    resetEditData()
  } else {
    isAddingMode.value = false // 关闭添加模式
  }
  updateMapCursor() // 同步光标
}
```

### <font style="color:rgb(0, 0, 0);">点击更新按钮（</font>`handleUpdateClick`<font style="color:rgb(0, 0, 0);">）</font>
```typescript
// 方法：点击更新按钮
const handleUpdateClick = async () => {
  isUpdatingMode.value = !isUpdatingMode.value
  if (isUpdatingMode.value) {
    ElMessage.primary('请在地图上点击需要修改的要素')
    isAddingMode.value = false
    isDeletingMode.value = false
    currentOptions.value = 'update'
    resetEditData()
  } else {
    ElMessage.success('已停止更新模式')
    isUpdatingMode.value = false
    // 停止更新模式
  }
  updateMapCursor()
}
```

### <font style="color:rgb(0, 0, 0);">点击删除按钮（</font>`handleDeleteClick`<font style="color:rgb(0, 0, 0);">）</font>
```typescript
// 方法：点击删除按钮
const handleDeleteClick = async () => {
  isDeletingMode.value = !isDeletingMode.value
  if (isDeletingMode.value) {
    ElMessage.primary('请在地图上点击需要删除的要素')
    currentOptions.value = 'delete'
    isAddingMode.value = false // 停止添加模式
    isUpdatingMode.value = false // 停止更新模式
    resetEditData() // 重置编辑数据
  } else {
    isDeletingMode.value = false // 停止删除模式
  }
  updateMapCursor()
}
```

## 封装 WFS-T 服务 API
**WFS-T（WFS Transaction）**<font style="color:rgba(0, 0, 0, 0.85);">：WFS 的扩展协议，支持</font>**写入**<font style="color:rgba(0, 0, 0, 0.85);">操作（新增、更新、删除地理要素）</font>

**通用事务处理（**`**editFeatures**`**）**

+ 统一维护 WFS-T XML 构建逻辑，减少重复代码，便于后续扩展（如批量操作）
+ 若需支持更复杂的操作（如条件更新、几何坐标修改），可在此函数中扩展 XML 片段生成逻辑

```typescript
import axios from 'axios'

// GeoServer基础URL
const baseURL = 'http://localhost:8085/geoserver'
// 图层固定信息
const LAYER_INFO = {
  workspace: 'fire_hydrant',
  layerName: 'fire_hydrants',
  namespace: 'http://localhost:8085/geoserver/fire_hydrant', // 工作区命名空间（需与GeoServer一致）
  geomField: 'geom', // 几何字段名
}
// 从GeoServer加载要素数据
export const loadFeatures = async (): Promise<GeoJSON.FeatureCollection> => {
  const url = `${baseURL}/wfs`
  // WFS GetFeature请求参数
  const params = {
    service: 'WFS',
    version: '1.1.0',
    request: 'GetFeature',
    typeName: 'fire_hydrant:fire_hydrants',
    outputFormat: 'application/json',
    srsName: 'urn:ogc:def:crs:EPSG::4326',
  }
  try {
    const response = await axios.get(url, { params })
    // 遍历循环，分割id fire_hydrants.1 --> 1
    response.data.features.forEach((feature: GeoJSON.Feature) => {
      if (feature.id) {
        const idParts = String(feature.id).split('.')
        feature.id = idParts.length > 1 ? idParts[1] : feature.id
      }
    })
    return response.data
  } catch (error) {
    console.error('加载要素失败:', error)
    throw error
  }
}

/**
 * 通用要素编辑函数（统一处理Insert/Update/Delete操作）
 * @param features 要素数据（根据操作类型提供不同字段）
 * @param operation 操作类型：insert/update/delete
 */
export const editFeatures = async (
  features: GeoJSON.Feature[],
  operation: 'insert' | 'update' | 'delete'
) => {
  if (features.length === 0) {
    console.log('没有需要保存的要素')
    return
  }
  const url = `${baseURL}/wfs`
  let TransactionFragments = ''
  switch (operation) {
      // 构建新增操作的XML片段
    case 'insert':
      break
    case 'update':
      break
    case 'delete':
      break
  }
  if (!TransactionFragments) {
    console.log('没有有效的要素需要保存')
    return
  }
  // 构建WFS-T事务请求XML
  const wfsTransaction = `
    <wfs:Transaction service="WFS" version="1.1.0"
      xmlns:wfs="http://www.opengis.net/wfs"
      xmlns:gml="http://www.opengis.net/gml"
      xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"
      xmlns:ogc="http://www.opengis.net/ogc">
      ${TransactionFragments}
    </wfs:Transaction>
  `
  console.log('WFS-T Transaction请求XML:', wfsTransaction)
  try {
    const response = await axios.post(url, wfsTransaction, {
      headers: {
        'Content-Type': 'text/xml', // 必须设置Content-Type为text/xml
        Accept: 'application/xml', // 响应数据类型为XML
      },
    })

    console.log(`WFS-T${operation}响应:`, response.data)
    return response.data
  } catch (error) {
    console.error('保存要素失败:', error)
  }
}
```

### <font style="color:rgb(0, 0, 0);">要素有效性校验</font>
```javascript
case 'insert':
  // 构建新增操作的XML片段
  TransactionFragments = features
    .map((feature) => {
      // 校验：只处理几何类型为MultiPoint且包含坐标的要素
      if (
        feature.geometry?.type !== 'MultiPoint' ||
        !feature.geometry.coordinates
      ) {
        console.warn('跳过无效的新增要素:', feature)
        return ''
      }
      // ...后续处理有效要素
    })
    .join('')
break
```

+ 校验逻辑：仅处理几何类型为 `MultiPoint` 且包含坐标的要素
+ 与图层定义的几何类型匹配，避免插入不符合要求的要素
+ 目的：确保插入的要素符合 GeoServer 图层的 schema 定义，减少请求失败概率

### <font style="color:rgb(0, 0, 0);">要素插入 XML 片段</font>
对于每个有效要素，生成对应的 `<wfs:Insert>` 片段（WFS-T 协议要求的格式）：

```javascript
// 提取坐标：MultiPoint的coordinates是[[x1,y1]]格式，取第一个点的坐标
const coords = feature.geometry.coordinates[0]
// 转换为GML要求的"x y"格式字符串
const pos = `${coords[0]} ${coords[1]}`

// 生成单个要素的Insert XML片段
return `
<wfs:Insert>
  <${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
    <!-- 几何字段：对应图层的geom字段，用GML格式描述 -->
    <${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
      <gml:MultiPoint srsName="EPSG:4326"> <!-- 坐标系：WGS84 -->
        <gml:pointMembers>
          <gml:Point><gml:pos>${pos}</gml:pos></gml:Point>
        </gml:pointMembers>
      </gml:MultiPoint>
    </${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
    
    <!-- 属性字段：对应要素的属性，与图层属性名一致 -->
    <${LAYER_INFO.workspace}:currentstatus>${feature.properties?.currentstatus}</${LAYER_INFO.workspace}:currentstatus>
    <${LAYER_INFO.workspace}:currentpressure>${feature.properties?.currentpressure}</${LAYER_INFO.workspace}:currentpressure>
    <${LAYER_INFO.workspace}:ManagementUnit>${feature.properties?.ManagementUnit}</${LAYER_INFO.workspace}:ManagementUnit>
    <${LAYER_INFO.workspace}:InstallationDate>${feature.properties?.InstallationDate}</${LAYER_INFO.workspace}:InstallationDate>
    <${LAYER_INFO.workspace}:ManagementUserNo>${feature.properties?.ManagementUserNo}</${LAYER_INFO.workspace}:ManagementUserNo>
  </${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
</wfs:Insert>
`
```

几何信息处理：

+ 将 GeoJSON 中的 `MultiPoint` 转换为 GML（地理标记语言）格式
+ 包含坐标系（`srsName="EPSG:4326"` 表示 WGS84 经纬度）和具体坐标（`gml:pos` 标签）

属性信息处理：

+ 将 GeoJSON 要素的 `properties` 中对应的属性（如 `currentstatus`、`ManagementUnit` 等）
+ 映射为 XML 标签，标签名格式为 `工作区:属性名`，与 GeoServer 图层的属性定义保持一致

### <font style="color:rgb(0, 0, 0);">组装完整的 WFS-T 事务 XML</font>
将所有单个要素的 `<wfs:Insert>` 片段拼接，包裹在 `<wfs:Transaction>` 根标签中，并声明必要的命名空间：

```javascript
const wfsTransaction = `
  <wfs:Transaction service="WFS" version="1.1.0"
    xmlns:wfs="http://www.opengis.net/wfs"  <!-- WFS命名空间 -->
    xmlns:gml="http://www.opengis.net/gml"  <!-- GML命名空间 -->
    xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"  <!-- 工作区命名空间（与GeoServer一致） -->
    xmlns:ogc="http://www.opengis.net/ogc">
    ${TransactionFragments}  <!-- 所有Insert片段的拼接结果 -->
  </wfs:Transaction>
`
```

命名空间作用：

+ 确保 XML 中使用的标签（如 `wfs:Insert`、`gml:MultiPoint`）能被 GeoServer 正确解析
+ 必须与 GeoServer 中工作区的命名空间配置一致

### <font style="color:rgb(0, 0, 0);">发送 POST 请求到 GeoServer</font>
通过 `axios.post` 将组装好的 XML 发送到 GeoServer 的 WFS 服务端点：

```javascript
const response = await axios.post(url, wfsTransaction, {
  headers: {
    'Content-Type': 'text/xml',  // 必须：WFS-T要求请求体为XML格式
    Accept: 'application/xml',   // 期望响应为XML格式
  },
})
```

请求头设置：`Content-Type: text/xml` ，告诉 GeoServer 请求体是 XML 格式，否则会导致解析失败

响应处理：GeoServer 会返回 XML 格式的响应，包含事务执行结果（成功 / 失败及原因）



直接调用通用编辑函数 `editFeatures`，并指定操作类型为 `'insert'`（插入），将具体逻辑委托给 `editFeatures` 处理

```typescript
const editFeatures = async (
  features: GeoJSON.Feature[],
  operation: 'insert' | 'update' | 'delete'
) => {
  if (features.length === 0) {
    console.log('没有需要保存的要素')
    return
  }
  const url = `${baseURL}/wfs`
  let TransactionFragments = ''
  switch (operation) {
    case 'insert':
      // 构建新增操作的XML片段
      TransactionFragments = features
        .map((feature) => {
          if (
            feature.geometry?.type !== 'MultiPoint' ||
            !feature.geometry.coordinates
          ) {
            console.warn('跳过无效的新增要素:', feature)
            return ''
          }
          const coords = feature.geometry.coordinates[0]
          const pos = `${coords[0]} ${coords[1]}`
          return `
          <wfs:Insert>
            <${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
              <${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
                <gml:MultiPoint srsName="EPSG:4326">
                  <gml:pointMembers>
                    <gml:Point><gml:pos>${pos}</gml:pos></gml:Point>
                  </gml:pointMembers>
                </gml:MultiPoint>
              </${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
              <${LAYER_INFO.workspace}:currentstatus>${feature.properties?.currentstatus}</${LAYER_INFO.workspace}:currentstatus>
              <${LAYER_INFO.workspace}:currentpressure>${feature.properties?.currentpressure}</${LAYER_INFO.workspace}:currentpressure>
              <${LAYER_INFO.workspace}:ManagementUnit>${feature.properties?.ManagementUnit}</${LAYER_INFO.workspace}:ManagementUnit>
              <${LAYER_INFO.workspace}:InstallationDate>${feature.properties?.InstallationDate}</${LAYER_INFO.workspace}:InstallationDate>
              <${LAYER_INFO.workspace}:ManagementUserNo>${feature.properties?.ManagementUserNo}</${LAYER_INFO.workspace}:ManagementUserNo>
            </${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
          </wfs:Insert>
        `
        })
        .join('')
      break
    case 'update':
      break
    case 'delete':
      break
  }
  if (!TransactionFragments) {
    console.log('没有有效的要素需要保存')
    return
  }
  // 构建WFS-T事务请求XML
  const wfsTransaction = `
    <wfs:Transaction service="WFS" version="1.1.0"
      xmlns:wfs="http://www.opengis.net/wfs"
      xmlns:gml="http://www.opengis.net/gml"
      xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"
      xmlns:ogc="http://www.opengis.net/ogc">
      ${TransactionFragments}
    </wfs:Transaction>
  `
  console.log('WFS-T Transaction请求XML:', wfsTransaction)
  try {
    const response = await axios.post(url, wfsTransaction, {
      headers: {
        'Content-Type': 'text/xml', // 必须设置Content-Type为text/xml
        Accept: 'application/xml', // 响应数据类型为XML
      },
    })

    console.log(`WFS-T${operation}响应:`, response.data)
    return response.data
  } catch (error) {
    console.error('保存要素失败:', error)
  }
}
```

## 添加要素功能实现
### <font style="color:rgb(0, 0, 0);">定义核心响应式变量</font>
`isEditing`控制 全局编辑模式 开关（开启后才显示添加 / 删除 / 更新按钮）  
`isAddingMode`控制 要素添加子模式 开关（编辑模式下的细分状态，仅用于新增要素）

`showEditFeatureDialog`控制 添加要素弹窗 的显示 / 隐藏

`FeatureForm` 存储添加要素的表单数据（与后端字段一一对应，用于提交）

`FeatureFormRules`表单验证规则对象

`formRef`关联表单 DOM

`geoJSONData`存储从后端加载的正式地理要素数据（地图渲染的核心数据源）

`tempGeoJSONData`存储临时编辑的要素数据（未保存到数据库前，避免污染正式数据）

```typescript
const selectedFeature = ref<GeoJSON.Feature | null>(null) // 当前选中的要素
const selectedFeatureCoord = ref<[number, number] | null>(null) // 当前要素经纬度
const selectedProperties = ref<HydrantProperties>({}) // 选中要素的属性表单
const tempCoordinates = ref<[number, number] | null>(null) // 临时添加要素经纬度

const isEditing = ref(false) // 是否处于编辑模式
const isAddingMode = ref(false) // 是否处于添加模式
const currentOptions = ref() // 当前编辑模式
const showEditFeatureDialog = ref(false) // 控制添加要素弹窗显示
// 编辑表单数据
const FeatureForm = ref({
  id: '',
  currentStatus: '',
  currentPressure: 0.0,
  managementUnit: '',
  installationDate: '',
  managementUserNo: '',
})
// 编辑表单验证规则
const FeatureFormRules = ref({
  currentPressure: [
    {
      required: true,
      type: 'number',
      message: '请输入压力值',
      trigger: 'blur',
    },
  ],
  managementUnit: [
    { required: true, message: '请输入管理单位', trigger: 'blur' },
  ],
  installationDate: [
    { required: true, message: '请选择安装日期', trigger: 'change' },
  ],
  managementUserNo: [
    { required: true, message: '请输入管理员编号', trigger: 'blur' },
  ],
})
const formRef = ref<FormInstance>() // 表单引用，明确指定类型

//GeoJSON数据 geoserver数据源
const geoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
// 临时存储数据 存储增加、更新、删除的要素
const tempGeoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
```

### 添加要素属性对话表单
```html
<!-- 添加要素弹窗表单 -->
<!-- 由响应式变量控制显示/隐藏 -->
<!-- 点击弹窗外部不关闭（避免误操作） -->

<el-dialog
  :title="
    isAddingMode ? '添加要素信息' : '删除要素信息 id:' + selectedFeature?.id
  "
  v-model="showEditFeatureDialog"
  width="400px"
  :close-on-click-modal="false"
>
  <!-- 表单：绑定表单实例、数据、验证规则 -->
  <el-form
    ref="formRef"
    :model="FeatureForm"
    :rules="FeatureFormRules"
    label-width="120px"
  >
    <!-- 1. 设备状态：下拉选择（正常/异常/错误） -->
    <el-form-item label="设备状态" prop="currentStatus">
      <el-select v-model="FeatureForm.currentStatus">
        <el-option label="正常" value="normal"></el-option>
        <el-option label="异常" value="Abnormal"></el-option>
        <el-option label="错误" value="Error"></el-option>
      </el-select>
    </el-form-item>

    <!-- 2. 当前压力：数字输入（步长 0.01，验证必填+数字类型） -->
    <el-form-item label="当前压力" prop="currentPressure">
      <el-input
        v-model.number="FeatureForm.currentPressure"
        type="number"
        step="0.01"
        placeholder="请输入压力值"
      ></el-input>
    </el-form-item>

    <!-- 3. 管理单位：文本输入（验证必填） -->
    <el-form-item label="管理单位" prop="managementUnit">
      <el-input
        v-model="FeatureForm.managementUnit"
        placeholder="请输入管理单位"
      ></el-input>
    </el-form-item>

    <!-- 4. 安装日期：日期选择器（格式 YYYY-MM-DD，验证必填） -->
    <el-form-item label="安装日期" prop="installationDate">
      <el-date-picker
        v-model="FeatureForm.installationDate"
        type="date"
        placeholder="选择安装日期"
        value-format="YYYY-MM-DD"
      ></el-date-picker>
    </el-form-item>

    <!-- 5. 管理员编号：文本输入（验证必填） -->
    <el-form-item label="管理员编号" prop="managementUserNo">
      <el-input
        v-model="FeatureForm.managementUserNo"
        placeholder="请输入管理员编号"
      ></el-input>
    </el-form-item>
  </el-form>

  <!-- 弹窗底部按钮：取消/确认添加 -->
  <template #footer>
    <el-button @click="showEditFeatureDialog = false">取消</el-button>
    <el-button
      type="primary"
      @click="handleFeatureFormSubmit(currentOptions)"
      >确认</el-button
    >
  </template>
</el-dialog>
```

### <font style="color:rgb(0, 0, 0);">点击地图添加要素（</font>`handleFeatureClickForAdd`<font style="color:rgb(0, 0, 0);">）</font>
用户在添加模式下点击地图时，获取坐标并唤起表单：

```typescript
// 监听地图点击事件
  map.on('click', (e) => {
    // 只在添加模式下处理地图点击事件
    if (isAddingMode.value) {
      handleFeatureClickForAdd(e)
    }
    showFeatureInfo.value = false // 点击地图空白区域时关闭hydrants-layer图层信息弹窗
  })
```

```typescript
// 处理点击要素添加
const handleFeatureClickForAdd = async (e: mapboxgl.MapMouseEvent) => {
  if (!map || !isAddingMode.value) return // 非添加模式不执行
  // 1. 获取点击位置的经纬度（Mapbox 坐标格式）
  tempCoordinates.value = e.lngLat.toArray() as [number, number]
  // 2. 重置表单（清空旧数据）
  FeatureForm.value = {
    id: '',
    currentStatus: '',
    currentPressure: 0.0,
    managementUnit: '',
    installationDate: '',
    managementUserNo: '',
  }
  // 3.显示弹窗
  showEditFeatureDialog.value = true
}
```

### <font style="color:rgb(0, 0, 0);">表单提交（</font>`handleAddFeatureSubmit`<font style="color:rgb(0, 0, 0);">）</font>
由于添加、更新都要操作表单，为表单控件提交按钮添加通用提交方法  
接收一个参数`operation`，其值只能是`'insert'`（插入）或`'update'`（更新）

```html
<!-- 弹窗底部按钮：取消/确认添加 -->
<template #footer>
  <el-button @click="showEditFeatureDialog = false">取消</el-button>
  <el-button
    type="primary"
    @click="handleFeatureFormSubmit(currentOptions)">确认</el-button>
</template>
```

进行表单验证

根据传入的`operation`参数值，判断是插入操作还是更新操作

然后分别调用`HandleAddFeatureFormSubmit`和`HandleUpdateFeatureFormSubmit`函数

处理相应的表单提交逻辑

```typescript
// 处理表单提交
const handleFeatureFormSubmit = async (operation: 'insert' | 'update') => {
  // 1. 表单验证：调用 Element Plus 表单验证方法，不通过则终止
  if (!formRef.value) return
  try {
    await formRef.value.validate()
  } catch (error) {
    console.error('表单验证失败:', error)
    return
  }
  if (operation === 'insert') {
    HandleAddFeatureFormSubmit()
  } else if (operation === 'update') {
    HandleUpdateFeatureFormSubmit()
  }
  updateMapCursor()
}
```

用户填写表单后，创建临时要素并渲染到地图（不直接修改正式数据）：

```typescript
// 处理添加要素表单提交
const HandleAddFeatureFormSubmit = async () => {
  if (!tempCoordinates.value) {
    ElMessage.error('请先在地图上选择位置')
    return
  }
  // 1. 创建临时要素：生成临时 ID（时间戳避免冲突），构造 GeoJSON 格式
  const newFeature: GeoJSON.Feature = {
    type: 'Feature',
    id: `temp_${Date.now()}`, // 临时 ID：避免与正式数据 ID 冲突
    geometry: { type: 'MultiPoint', coordinates: [tempCoordinates.value] }, // 几何类型为多点（取第一个点）
    properties: {
      // 表单数据映射到要素属性
      currentStatus: FeatureForm.value.currentStatus,
      currentPressure: FeatureForm.value.currentPressure,
      managementUnit: FeatureForm.value.managementUnit,
      installationDate: FeatureForm.value.installationDate,
      managementUserNo: FeatureForm.value.managementUserNo,
    },
  }

  // 2. 更新临时数据：将新要素添加到临时数据源（tempGeoJSONData）
  tempGeoJSONData.value.features.push(newFeature)

  // 3. 更新地图渲染：合并原始数据和临时数据，确保所有要素都显示在地图上
  const source = map?.getSource('hydrants')
  if (source && 'setData' in source) {
    // 创建一个包含所有要素的新数据集
    const allFeatures: GeoJSON.Feature[] = [...geoJSONData.value.features]

    // 添加临时数据（包括新增和修改的要素）
    const combinedData: GeoJSON.FeatureCollection = {
      type: 'FeatureCollection',
      features: [...allFeatures, ...tempGeoJSONData.value.features],
    }

    // 更新地图数据源
    ;(source as mapboxgl.GeoJSONSource).setData(combinedData)
  }

  // 4. 创建自定义标记：调用前文的 creatMarker 方法，添加到地图和标记数组
  const marker = creatMarker(newFeature)
  if (marker) {
    markers.push(marker)
    marker.addTo(map as mapboxgl.Map)
  }

  // 5. 交互反馈：关闭弹窗，提示用户“需点击保存提交更改”
  ElMessage.success('添加成功，点击保存提交更改')
  showEditFeatureDialog.value = false
}
```

### <font style="color:rgb(0, 0, 0);">数据持久化（临时数据保存到数据库）</font>
同样使用通用保存方法，根据不同操作状态调用后端 `editFeatures`

```typescript
const editFeatures = async (
  features: GeoJSON.Feature[],
  operation: 'insert' | 'update' | 'delete'
)
```

```html
<!-- 2. 编辑模式下显示的工具按钮（添加/删除/更新/保存） -->
<div v-if="isEditingMode" class="edit-tool">
  <!-- 要素添加按钮：根据 isAddingMode 切换文本和类型 -->
  <!-- 要素更新按钮：根据 isUpdatingMode 切换文本和类型 -->
  <!-- 要素删除按钮：根据 isDeletingMode 切换文本和类型 -->
  <!-- 保存更改按钮：触发数据持久化 -->
  <el-button type="primary" @click="saveChanges(currentOptions)">保存更改</el-button>
</div>
```

通过 `saveChanges` 方法，将 `tempGeoJSONData` 中的临时要素提交到后端，完成正式保存：

```typescript
// 保存所有更改（区分新增/更新/删除）
const saveChanges = async (operation: 'insert' | 'update' | 'delete') => {
  if (!tempGeoJSONData.value) return
  try {
    ElMessage.info('正在保存数据...')
    switch (operation) {
      case 'insert':
        await editFeatures(tempGeoJSONData.value.features, 'insert')
        console.log('执行新增 insert 操作')
        break
      case 'update':
        await editFeatures(tempGeoJSONData.value.features, 'update')
        console.log('执行更新 update 操作')
        break
      case 'delete':
        await editFeatures(tempGeoJSONData.value.features, 'delete')
        console.log('执行删除 delete 操作')
        break
    }
    ElMessage.success('数据保存成功')
    // 保存成功后，清空临时数据并重新加载正式数据（更新地图显示）
    tempGeoJSONData.value.features = []
    await loadGeoJSONData()
  } catch (error) {
    ElMessage.error('数据保存失败，请重试')
    console.error('保存失败:', error)
  }

```

临时数据仅在用户确认后才提交到数据库，避免误操作导致正式数据错误

## API 添加接口
### <font style="color:rgb(0, 0, 0);">要素有效性校验</font>
+ 校验逻辑：仅处理几何类型为 `MultiPoint` 且包含坐标的要素
+ 与图层定义的几何类型匹配，避免插入不符合要求的要素
+ 目的：确保插入的要素符合 GeoServer 图层的 schema 定义，减少请求失败概率

```javascript
case 'insert':
  // 构建新增操作的XML片段
  TransactionFragments = features
    .map((feature) => {
      // 校验：只处理几何类型为MultiPoint且包含坐标的要素
      if (
        feature.geometry?.type !== 'MultiPoint' ||
        !feature.geometry.coordinates
      ) {
        console.warn('跳过无效的新增要素:', feature)
        return ''
      }
      // ...后续处理有效要素
    })
    .join('')
break
```

### <font style="color:rgb(0, 0, 0);">要素插入 XML 片段</font>
对于每个有效要素，生成对应的 `<wfs:Insert>` 片段（WFS-T 协议要求的格式）：

几何信息处理：

+ 将 GeoJSON 中的 `MultiPoint` 转换为 GML（地理标记语言）格式
+ 包含坐标系（`srsName="EPSG:4326"` 表示 WGS84 经纬度）和具体坐标（`gml:pos` 标签）

属性信息处理：

+ 将 GeoJSON 要素的 `properties` 中对应的属性（如 `currentstatus`、`ManagementUnit` 等）
+ 映射为 XML 标签，标签名格式为 `工作区:属性名`，与 GeoServer 图层的属性定义保持一致

```javascript
// 提取坐标：MultiPoint的coordinates是[[x1,y1]]格式，取第一个点的坐标
const coords = feature.geometry.coordinates[0]
// 转换为GML要求的"x y"格式字符串
const pos = `${coords[0]} ${coords[1]}`

// 生成单个要素的Insert XML片段
return `
<wfs:Insert>
  <${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
    <!-- 几何字段：对应图层的geom字段，用GML格式描述 -->
    <${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
      <gml:MultiPoint srsName="EPSG:4326"> <!-- 坐标系：WGS84 -->
        <gml:pointMembers>
          <gml:Point><gml:pos>${pos}</gml:pos></gml:Point>
        </gml:pointMembers>
      </gml:MultiPoint>
    </${LAYER_INFO.workspace}:${LAYER_INFO.geomField}>
    
    <!-- 属性字段：对应要素的属性，与图层属性名一致 -->
    <${LAYER_INFO.workspace}:currentstatus>${feature.properties?.currentstatus}</${LAYER_INFO.workspace}:currentstatus>
    <${LAYER_INFO.workspace}:currentpressure>${feature.properties?.currentpressure}</${LAYER_INFO.workspace}:currentpressure>
    <${LAYER_INFO.workspace}:ManagementUnit>${feature.properties?.ManagementUnit}</${LAYER_INFO.workspace}:ManagementUnit>
    <${LAYER_INFO.workspace}:InstallationDate>${feature.properties?.InstallationDate}</${LAYER_INFO.workspace}:InstallationDate>
    <${LAYER_INFO.workspace}:ManagementUserNo>${feature.properties?.ManagementUserNo}</${LAYER_INFO.workspace}:ManagementUserNo>
  </${LAYER_INFO.workspace}:${LAYER_INFO.layerName}>
</wfs:Insert>
`
```

### <font style="color:rgb(0, 0, 0);">组装完整的 WFS-T 事务 XML</font>
将所有单个要素的 `<wfs:Insert>` 片段拼接，包裹在 `<wfs:Transaction>` 根标签中，并声明必要的命名空间：

```typescript
if (!TransactionFragments) {
    console.log('没有有效的要素需要保存')
    return
  }
  // 构建WFS-T事务请求XML
  const wfsTransaction = `
    <wfs:Transaction service="WFS" version="1.1.0"
      xmlns:wfs="http://www.opengis.net/wfs"
      xmlns:gml="http://www.opengis.net/gml"
      xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"
      xmlns:ogc="http://www.opengis.net/ogc">
      ${TransactionFragments}
    </wfs:Transaction>
  `
  console.log('WFS-T Transaction请求XML:', wfsTransaction)
  try {
    const response = await axios.post(url, wfsTransaction, {
      headers: {
        'Content-Type': 'text/xml', // 必须设置Content-Type为text/xml
        Accept: 'application/xml', // 响应数据类型为XML
      },
    })

    console.log(`WFS-T${operation}响应:`, response.data)
    return response.data
  } catch (error) {
    console.error('保存要素失败:', error)
  }
```

## 更新要素功能实现
### <font style="color:rgb(0, 0, 0);">定义核心响应式变量</font>
`isEditing`控制 全局编辑模式 开关（开启后才显示添加 / 删除 / 更新按钮）  
`isAddingMode`控制 要素添加子模式 开关（编辑模式下的细分状态，仅用于新增要素）

`showEditFeatureDialog`控制 添加要素弹窗 的显示 / 隐藏

`FeatureForm` 存储添加要素的表单数据（与后端字段一一对应，用于提交）

`FeatureFormRules`表单验证规则对象

`formRef`关联表单 DOM

`geoJSONData`存储从后端加载的正式地理要素数据（地图渲染的核心数据源）

`tempGeoJSONData`存储临时编辑的要素数据（未保存到数据库前，避免污染正式数据）

```typescript
const selectedFeature = ref<GeoJSON.Feature | null>(null) // 当前选中的要素
const selectedFeatureCoord = ref<[number, number] | null>(null) // 当前要素经纬度
const selectedProperties = ref<HydrantProperties>({}) // 选中要素的属性表单
const tempCoordinates = ref<[number, number] | null>(null) // 临时添加要素经纬度

const isEditing = ref(false) // 是否处于编辑模式
const isAddingMode = ref(false) // 是否处于添加模式
const currentOptions = ref() // 当前编辑模式
const showEditFeatureDialog = ref(false) // 控制添加要素弹窗显示
// 编辑表单数据
const FeatureForm = ref({
  id: '',
  currentStatus: '',
  currentPressure: 0.0,
  managementUnit: '',
  installationDate: '',
  managementUserNo: '',
})
// 编辑表单验证规则
const FeatureFormRules = ref({
  currentPressure: [
    {
      required: true,
      type: 'number',
      message: '请输入压力值',
      trigger: 'blur',
    },
  ],
  managementUnit: [
    { required: true, message: '请输入管理单位', trigger: 'blur' },
  ],
  installationDate: [
    { required: true, message: '请选择安装日期', trigger: 'change' },
  ],
  managementUserNo: [
    { required: true, message: '请输入管理员编号', trigger: 'blur' },
  ],
})
const formRef = ref<FormInstance>() // 表单引用，明确指定类型

//GeoJSON数据 geoserver数据源
const geoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
// 临时存储数据 存储增加、更新、删除的要素
const tempGeoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
```

### 添加要素属性对话表单
```html
<!-- 添加要素弹窗表单 -->
<!-- 由响应式变量控制显示/隐藏 -->
<!-- 点击弹窗外部不关闭（避免误操作） -->

<el-dialog
  :title="
    isAddingMode ? '添加要素信息' : '删除要素信息 id:' + selectedFeature?.id
  "
  v-model="showEditFeatureDialog"
  width="400px"
  :close-on-click-modal="false"
>
  <!-- 表单：绑定表单实例、数据、验证规则 -->
  <el-form
    ref="formRef"
    :model="FeatureForm"
    :rules="FeatureFormRules"
    label-width="120px"
  >
    <!-- 1. 设备状态：下拉选择（正常/异常/错误） -->
    <el-form-item label="设备状态" prop="currentStatus">
      <el-select v-model="FeatureForm.currentStatus">
        <el-option label="正常" value="normal"></el-option>
        <el-option label="异常" value="Abnormal"></el-option>
        <el-option label="错误" value="Error"></el-option>
      </el-select>
    </el-form-item>

    <!-- 2. 当前压力：数字输入（步长 0.01，验证必填+数字类型） -->
    <el-form-item label="当前压力" prop="currentPressure">
      <el-input
        v-model.number="FeatureForm.currentPressure"
        type="number"
        step="0.01"
        placeholder="请输入压力值"
      ></el-input>
    </el-form-item>

    <!-- 3. 管理单位：文本输入（验证必填） -->
    <el-form-item label="管理单位" prop="managementUnit">
      <el-input
        v-model="FeatureForm.managementUnit"
        placeholder="请输入管理单位"
      ></el-input>
    </el-form-item>

    <!-- 4. 安装日期：日期选择器（格式 YYYY-MM-DD，验证必填） -->
    <el-form-item label="安装日期" prop="installationDate">
      <el-date-picker
        v-model="FeatureForm.installationDate"
        type="date"
        placeholder="选择安装日期"
        value-format="YYYY-MM-DD"
      ></el-date-picker>
    </el-form-item>

    <!-- 5. 管理员编号：文本输入（验证必填） -->
    <el-form-item label="管理员编号" prop="managementUserNo">
      <el-input
        v-model="FeatureForm.managementUserNo"
        placeholder="请输入管理员编号"
      ></el-input>
    </el-form-item>
  </el-form>

  <!-- 弹窗底部按钮：取消/确认添加 -->
  <template #footer>
    <el-button @click="showEditFeatureDialog = false">取消</el-button>
    <el-button
      type="primary"
      @click="handleFeatureFormSubmit(currentOptions)"
      >确认</el-button
    >
  </template>
</el-dialog>
```

### <font style="color:rgb(0, 0, 0);">点击地图更新要素（</font>`handleFeatureClickForUpdate`<font style="color:rgb(0, 0, 0);">）</font>
用户在添加模式下点击地图时，获取坐标并唤起表单：

```typescript
// 监听hydrants-layer图层点击事件
map.on('click', 'hydrants-layer', (e) => {
  // 监听默认模式下的点击事件
  if (!isUpdatingMode.value && !isDeletingMode.value) {
    handleFeatureClickForInfo(e)
    showFeatureInfo.value = true // 打开信息弹窗
  }
  // 监听更新模式下的点击事件
  if (isUpdatingMode.value) {
    handleFeatureClickForUpdate(e)
  }
  // 监听删除模式下的点击事件
  if (isDeletingMode.value) {
    handleFeatureClickForDelete(e)
  }
})
```

```typescript
// 处理 点击要素更新
const handleFeatureClickForUpdate = async (e: mapboxgl.MapMouseEvent) => {
  if (!map || !isUpdatingMode.value) return // 非更新模式不执行
  GetClickFeature(e)
  console.log('当前点击更新要素:', selectedFeature.value)
  console.log('当前点击更新要素属性:', selectedProperties.value)
  // 重置表单数据为当前选中要素属性
  if (selectedFeature.value) {
    FeatureForm.value = {
      id: String(selectedFeature.value.id || ''),
      currentStatus: selectedProperties.value.currentStatus || '',
      currentPressure:
        Number(selectedFeature.value.properties?.currentpressure) || 0,
      managementUnit: selectedProperties.value.managementUnit || '',
      installationDate: selectedProperties.value.installationDate || '',
      managementUserNo: selectedProperties.value.managementUserNo || '',
    }
  // 显示弹窗
    showEditFeatureDialog.value = true
  }
}
```

### <font style="color:rgb(0, 0, 0);">表单提交（</font>`HandleUpdateFeatureFormSubmit`<font style="color:rgb(0, 0, 0);">）</font>
由于添加、更新都要操作表单，为表单控件提交按钮添加通用提交方法  
接收一个参数`operation`，其值只能是`'insert'`（插入）或`'update'`（更新）

```html
<!-- 弹窗底部按钮：取消/确认添加 -->
<template #footer>
  <el-button @click="showEditFeatureDialog = false">取消</el-button>
  <el-button
    type="primary"
    @click="handleFeatureFormSubmit(currentOptions)">确认</el-button>
</template>
```

进行表单验证

根据传入的`operation`参数值，判断是插入操作还是更新操作

然后分别调用`HandleAddFeatureFormSubmit`和`HandleUpdateFeatureFormSubmit`函数

处理相应的表单提交逻辑

```typescript
// 处理表单提交
const handleFeatureFormSubmit = async (operation: 'insert' | 'update') => {
  // 1. 表单验证：调用 Element Plus 表单验证方法，不通过则终止
  if (!formRef.value) return
  try {
    await formRef.value.validate()
  } catch (error) {
    console.error('表单验证失败:', error)
    return
  }
  if (operation === 'insert') {
    HandleAddFeatureFormSubmit()
  } else if (operation === 'update') {
    HandleUpdateFeatureFormSubmit()
  }
  updateMapCursor()
}
```

用户填写表单后，创建临时要素并渲染到地图（不直接修改正式数据）：

```typescript
// 处理更新要素表单提交
const handleUpdateFeatureFormSubmit = async () => {
  console.log('点击更新提交')
  if (!selectedFeature.value) return
  // 1. 创建更新临时要素
  const updatedFeature: GeoJSON.Feature = {
    type: 'Feature',
    id: selectedFeature.value?.id, // 正式数据对应 ID
    geometry: selectedFeature.value.geometry,
    properties: {
      // 表单数据映射到要素属性
      currentStatus: FeatureForm.value.currentStatus,
      currentPressure: FeatureForm.value.currentPressure,
      managementUnit: FeatureForm.value.managementUnit,
      installationDate: FeatureForm.value.installationDate,
      managementUserNo: FeatureForm.value.managementUserNo,
    },
  }

  // 2. 更新临时数据：将修改要素替换到临时数据中
  tempGeoJSONData.value.features.push(updatedFeature)
  // 3. 为修改的每个要素重新创建marker
  tempGeoJSONData.value.features.forEach((feature: GeoJSON.Feature) => {
    // 清除markers数组中的旧标记
    if (markers.length > 0) {
      markers.forEach((marker) => {
        if (marker.getElement().dataset.featureId === String(feature.id)) {
          marker.remove()
        }
      })
    }
  })
  const marker = creatMarker(updatedFeature)
  console.log(marker)
  // 只有成功创建标记时才添加到数组和地图
  if (marker) {
    markers.push(marker)
    marker.addTo(map as mapboxgl.Map)
  }
  // 4. 更新地图渲染：合并原始数据和临时数据，确保所有要素都显示在地图上
  const source = map?.getSource('hydrants')
  if (source && 'setData' in source) {
    // 创建一个包含所有要素的新数据集
    const allFeatures: GeoJSON.Feature[] = [...geoJSONData.value.features]
    // map方法遍历tempGeoJSONData.value.features数组，提取每个要素的id属性
    const editFeatureIds = tempGeoJSONData.value.features.map((f) => f.id)
    // 检查每个要素的id是否存在于editFeatureIds数组中,选出未被编辑的要素
    const filteredFeatures = allFeatures.filter(
      (feature) => !editFeatureIds.includes(feature.id)
    )

    // 将原始筛选出的未修改的要素和已修改的要素组合在一起
    const combinedData: GeoJSON.FeatureCollection = {
      type: 'FeatureCollection',
      features: [...filteredFeatures, ...tempGeoJSONData.value.features],
    }
    console.log(combinedData)
    // 更新地图数据源
    ;(source as mapboxgl.GeoJSONSource).setData(combinedData)
  }

  // 5. 交互反馈：关闭弹窗，提示用户"需点击保存提交更改"
  ElMessage.success('修改成功，点击保存提交更改')
  showEditFeatureDialog.value = false
  updateMapCursor()
}
```

### <font style="color:rgb(0, 0, 0);">数据持久化（临时数据保存到数据库）</font>
同样使用通用保存方法，根据不同操作状态调用后端 `editFeatures`

```typescript
const editFeatures = async (
  features: GeoJSON.Feature[],
  operation: 'insert' | 'update' | 'delete'
)
```

```html
<!-- 2. 编辑模式下显示的工具按钮（添加/删除/更新/保存） -->
<div v-if="isEditingMode" class="edit-tool">
  <!-- 要素添加按钮：根据 isAddingMode 切换文本和类型 -->
  <!-- 要素更新按钮：根据 isUpdatingMode 切换文本和类型 -->
  <!-- 要素删除按钮：根据 isDeletingMode 切换文本和类型 -->
  <!-- 保存更改按钮：触发数据持久化 -->
  <el-button type="primary" @click="saveChanges(currentOptions)">保存更改</el-button>
</div>
```

通过 `saveChanges` 方法，将 `tempGeoJSONData` 中的临时要素提交到后端，完成正式保存：

```typescript
// 保存所有更改（区分新增/更新/删除）
const saveChanges = async (operation: 'insert' | 'update' | 'delete') => {
  if (!tempGeoJSONData.value) return
  try {
    ElMessage.info('正在保存数据...')
    switch (operation) {
      case 'insert':
        await editFeatures(tempGeoJSONData.value.features, 'insert')
        console.log('执行新增 insert 操作')
        break
      case 'update':
        await editFeatures(tempGeoJSONData.value.features, 'update')
        console.log('执行更新 update 操作')
        break
      case 'delete':
        await editFeatures(tempGeoJSONData.value.features, 'delete')
        console.log('执行删除 delete 操作')
        break
    }
    ElMessage.success('数据保存成功')
    // 保存成功后，清空临时数据并重新加载正式数据（更新地图显示）
    tempGeoJSONData.value.features = []
    await loadGeoJSONData()
  } catch (error) {
    ElMessage.error('数据保存失败，请重试')
    console.error('保存失败:', error)
  }

```

临时数据仅在用户确认后才提交到数据库，避免误操作导致正式数据错误

## API 更新接口
### <font style="color:rgb(0, 0, 0);">要素有效性校验</font>
```javascript
case 'update':
  // 构建更新操作的XML片段
  TransactionFragments = features
    .map((feature) => {
      if (
        feature.geometry?.type !== 'Point' ||
        !feature.id ||
        !feature.properties
      ) {
        console.warn('跳过无效的更新要素:', feature)
        return ''
      }
      const id = feature.id
      return `
      `
    })
    .join('')
  break
```

### <font style="color:rgb(0, 0, 0);">构建单个要素的插入 XML 片段</font>
对于每个有效要素，生成对应的 `<wfs:Update>` 片段（WFS-T 协议要求的格式）：

`<wfs:Property>` 标签用于指定要更新的属性及其新值：

+ `<wfs:Name>` 标签指定**属性名**：`currentStatus`、`currentPressure` 等
+ `<wfs:Value>` 标签指定**属性的新值**，值通过变量引用

`<ogc:Filter>` 标签及其内部的 `<ogc:FeatureId>` 标签用于定位要更新的具体要素

+ 通过 `fid="fire_hydrants.${id}"` 来指定
+ `fire_hydrants` 是 geoserver 自动加的图层前缀，`${id}` 是通过变量引用的具体要素 ID

```javascript
return `
<wfs:Update typeName="${LAYER_INFO.workspace}:${LAYER_INFO.layerName}">
  <wfs:Property>
    <wfs:Name>currentStatus</wfs:Name>
    <wfs:Value>${feature.properties?.currentStatus}</wfs:Value>
  </wfs:Property>
  <wfs:Property>
    <wfs:Name>currentPressure</wfs:Name>
    <wfs:Value>${feature.properties?.currentPressure}</wfs:Value>
  </wfs:Property>
  <wfs:Property>
    <wfs:Name>managementUnit</wfs:Name>
    <wfs:Value>${feature.properties?.managementUnit}</wfs:Value>
  </wfs:Property>
  <wfs:Property>
    <wfs:Name>installationDate</wfs:Name>
    <wfs:Value>${feature.properties?.installationDate}</wfs:Value>
  </wfs:Property>
  <wfs:Property>
    <wfs:Name>managementUserNo</wfs:Name>
    <wfs:Value>${feature.properties?.managementUserNo}</wfs:Value>
  </wfs:Property>
  <!-- 定位要更新的要素：通过 ID 过滤 -->
  <ogc:Filter>
    <ogc:FeatureId fid="fire_hydrants.${id}"/>
  </ogc:Filter>
</wfs:Update>
`
```

### <font style="color:rgb(0, 0, 0);">组装完整的 WFS-T 事务 XML</font>
将所有单个要素的 `<wfs:Insert>` 片段拼接，包裹在 `<wfs:Transaction>` 根标签中，并声明必要的命名空间：

```javascript
  if (!TransactionFragments) {
    console.log('没有有效的要素需要保存')
    return
  }
  // 构建WFS-T事务请求XML
  const wfsTransaction = `
    <wfs:Transaction service="WFS" version="1.1.0"
      xmlns:wfs="http://www.opengis.net/wfs"
      xmlns:gml="http://www.opengis.net/gml"
      xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"
      xmlns:ogc="http://www.opengis.net/ogc">
      ${TransactionFragments}
    </wfs:Transaction>
  `
  console.log('WFS-T Transaction请求XML:', wfsTransaction)
  try {
    const response = await axios.post(url, wfsTransaction, {
      headers: {
        'Content-Type': 'text/xml', // 必须设置Content-Type为text/xml
        Accept: 'application/xml', // 响应数据类型为XML
      },
    })

    console.log(`WFS-T${operation}响应:`, response.data)
    return response.data
  } catch (error) {
    console.error('保存要素失败:', error)
  }
```

## 删除要素功能实现
### <font style="color:rgb(0, 0, 0);">定义核心响应式变量</font>
`isEditing`控制 全局编辑模式 开关（开启后才显示添加 / 删除 / 更新按钮）  
`isAddingMode`控制 要素添加子模式 开关（编辑模式下的细分状态，仅用于新增要素）

`showEditFeatureDialog`控制 添加要素弹窗 的显示 / 隐藏

`FeatureForm` 存储添加要素的表单数据（与后端字段一一对应，用于提交）

`FeatureFormRules`表单验证规则对象

`formRef`关联表单 DOM

`geoJSONData`存储从后端加载的正式地理要素数据（地图渲染的核心数据源）

`tempGeoJSONData`存储临时编辑的要素数据（未保存到数据库前，避免污染正式数据）

```typescript
const selectedFeature = ref<GeoJSON.Feature | null>(null) // 当前选中的要素
const selectedFeatureCoord = ref<[number, number] | null>(null) // 当前要素经纬度
const selectedProperties = ref<HydrantProperties>({}) // 选中要素的属性表单
const tempCoordinates = ref<[number, number] | null>(null) // 临时添加要素经纬度

const isEditing = ref(false) // 是否处于编辑模式
const isAddingMode = ref(false) // 是否处于添加模式
const currentOptions = ref() // 当前编辑模式
const showEditFeatureDialog = ref(false) // 控制添加要素弹窗显示
// 编辑表单数据
const FeatureForm = ref({
  id: '',
  currentStatus: '',
  currentPressure: 0.0,
  managementUnit: '',
  installationDate: '',
  managementUserNo: '',
})
// 编辑表单验证规则
const FeatureFormRules = ref({
  currentPressure: [
    {
      required: true,
      type: 'number',
      message: '请输入压力值',
      trigger: 'blur',
    },
  ],
  managementUnit: [
    { required: true, message: '请输入管理单位', trigger: 'blur' },
  ],
  installationDate: [
    { required: true, message: '请选择安装日期', trigger: 'change' },
  ],
  managementUserNo: [
    { required: true, message: '请输入管理员编号', trigger: 'blur' },
  ],
})
const formRef = ref<FormInstance>() // 表单引用，明确指定类型

//GeoJSON数据 geoserver数据源
const geoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
// 临时存储数据 存储增加、更新、删除的要素
const tempGeoJSONData = ref<GeoJSON.FeatureCollection>({
  type: 'FeatureCollection',
  features: [],
})
```



### <font style="color:rgb(0, 0, 0);">点击地图删除要素（</font>`handleFeatureClickForDelete`<font style="color:rgb(0, 0, 0);">）</font>
用户在删除模式下点击地图时，获取要素信息并唤起确认对话框：

```typescript
// 处理点击要素删除
const handleFeatureClickForDelete = async (e: mapboxgl.MapMouseEvent) => {
  if (!isDeletingMode.value) return // 非删除模式下不处理
  GetClickFeature(e)
  try {
    await ElMessageBox.confirm(
      '是否确认删除要素id :' + selectedFeature.value?.id,
      {
        confirmButtonText: '确认',
        cancelButtonText: '取消',
        type: 'warning',
      }
    )
    console.log('点击了确认按钮')
    HandleDeleteFeature()
  } catch {
    console.log('点击了取消按钮')
    // 用户取消操作，不退出编辑模式，保持原有状态
    return
  }
}
```

### 删除逻辑
```typescript
// 处理 删除要素
const HandleDeleteFeature = async () => {
  if (!selectedFeature.value) return
  // 1. 删除的要素
  const deleteFeature: GeoJSON.Feature = {
    type: 'Feature',
    id: selectedFeature.value.id, // 正式数据对应 ID
    geometry: selectedFeature.value.geometry,
    properties: {
      // 表单数据映射到要素属性
      currentStatus: FeatureForm.value.currentStatus,
      currentPressure: FeatureForm.value.currentPressure,
      managementUnit: FeatureForm.value.managementUnit,
      installationDate: FeatureForm.value.installationDate,
      managementUserNo: FeatureForm.value.managementUserNo,
    },
  }
  // 2. 更新临时数据并刷新地图
  tempGeoJSONData.value.features.push(deleteFeature)
  // 4. 删除要素删除marker
  tempGeoJSONData.value.features.forEach((feature: GeoJSON.Feature) => {
    // 根据自定义属性匹配marker id
    if (markers.length > 0) {
      markers.forEach((marker) => {
        if (marker.getElement().dataset.featureId === String(feature.id)) {
          marker.remove()
        }
      })
    }
  })
  // 5. 更新地图渲染：合并原始数据和临时数据，确保所有要素都显示在地图上
  const source = map?.getSource('hydrants')
  if (source && 'setData' in source) {
    const allFeatures: GeoJSON.Feature[] = [...geoJSONData.value.features] // 创建一个包含所有要素的新数据集

    const deleteFeatureIds = tempGeoJSONData.value.features.map((f) => f.id) // 遍历提取每一个删除元素id属性值
    // 过滤掉包含删除元素id对应的元素
    const filteredFeatures = allFeatures.filter(
      (feature) => !deleteFeatureIds.includes(feature.id)
    )
    // 添加原始未修改的要素和已修改的要素
    const combinedData: GeoJSON.FeatureCollection = {
      type: 'FeatureCollection',
      features: [...filteredFeatures, ...tempGeoJSONData.value.features],
    }
    ;(source as mapboxgl.GeoJSONSource).setData(combinedData)
  }
  // 6. 交互反馈：关闭弹窗，提示用户“需点击保存提交更改”
  ElMessage.success('修改成功，点击保存提交更改')
  showEditFeatureDialog.value = false
  updateMapCursor()
}
```

### <font style="color:rgb(0, 0, 0);">数据持久化（临时数据保存到数据库）</font>
同样使用通用保存方法，根据不同操作状态调用后端 `editFeatures`

```typescript
const editFeatures = async (
  features: GeoJSON.Feature[],
  operation: 'insert' | 'update' | 'delete'
)
```

```html
<!-- 2. 编辑模式下显示的工具按钮（添加/删除/更新/保存） -->
<div v-if="isEditingMode" class="edit-tool">
  <!-- 要素添加按钮：根据 isAddingMode 切换文本和类型 -->
  <!-- 要素更新按钮：根据 isUpdatingMode 切换文本和类型 -->
  <!-- 要素删除按钮：根据 isDeletingMode 切换文本和类型 -->
  <!-- 保存更改按钮：触发数据持久化 -->
  <el-button type="primary" @click="saveChanges(currentOptions)">保存更改</el-button>
</div>
```

通过 `saveChanges` 方法，将 `tempGeoJSONData` 中的临时要素提交到后端，完成正式保存：

```typescript
// 保存所有更改（区分新增/更新/删除）
const saveChanges = async (operation: 'insert' | 'update' | 'delete') => {
  if (!tempGeoJSONData.value) return
  try {
    ElMessage.info('正在保存数据...')
    switch (operation) {
      case 'insert':
        await editFeatures(tempGeoJSONData.value.features, 'insert')
        console.log('执行新增 insert 操作')
        break
      case 'update':
        await editFeatures(tempGeoJSONData.value.features, 'update')
        console.log('执行更新 update 操作')
        break
      case 'delete':
        await editFeatures(tempGeoJSONData.value.features, 'delete')
        console.log('执行删除 delete 操作')
        break
    }
    ElMessage.success('数据保存成功')
    // 保存成功后，清空临时数据并重新加载正式数据（更新地图显示）
    tempGeoJSONData.value.features = []
    await loadGeoJSONData()
  } catch (error) {
    ElMessage.error('数据保存失败，请重试')
    console.error('保存失败:', error)
  }

```

临时数据仅在用户确认后才提交到数据库，避免误操作导致正式数据错误

## API 更新接口
### <font style="color:rgb(0, 0, 0);">要素有效性校验</font>
```javascript
case 'delete':
  // 构建更新操作的XML片段
  TransactionFragments = features
    .map((feature) => {
      if (
        feature.geometry?.type !== 'Point' ||
        !feature.id ||
        !feature.properties
      ) {
        console.warn('跳过无效的更新要素:', feature)
        return ''
      }
      const id = feature.id
      return `
      <wfs:Delete typeName="${LAYER_INFO.workspace}:${LAYER_INFO.layerName}">
        <ogc:Filter>
            <ogc:FeatureId fid="fire_hydrants.${id}" />
        </ogc:Filter>
      </wfs:Delete>
      `
    })
    .join('')
  break
```

### <font style="color:rgb(0, 0, 0);">要素删除 XML 片段</font>
`typeName`属性指定要删除要素所在的图层

工作空间：图层名称

`<ogc:Filter>`：用于定义过滤条件，明确要删除的具体要素

`<ogc:FeatureId fid="fire_hydrants.${id}" />`：

+ 通过`FeatureId`指定要删除要素的唯一标识符，这里`fid`属性值为`fire_hydrants.${id}` 
+ `fire_hydrants`是 geoserver 图层前缀，`${id}`是具体要素的编号

```javascript
 return `
  <wfs:Delete typeName="${LAYER_INFO.workspace}:${LAYER_INFO.layerName}">
    <ogc:Filter>
        <ogc:FeatureId fid="fire_hydrants.${id}" />
    </ogc:Filter>
  </wfs:Delete>
  `
```

### <font style="color:rgb(0, 0, 0);">组装完整的 WFS-T 事务 XML</font>
将所有单个要素的 `<wfs:Insert>` 片段拼接，包裹在 `<wfs:Transaction>` 根标签中，并声明必要的命名空间：

```javascript
  if (!TransactionFragments) {
    console.log('没有有效的要素需要保存')
    return
  }
  // 构建WFS-T事务请求XML
  const wfsTransaction = `
    <wfs:Transaction service="WFS" version="1.1.0"
      xmlns:wfs="http://www.opengis.net/wfs"
      xmlns:gml="http://www.opengis.net/gml"
      xmlns:${LAYER_INFO.workspace}="${LAYER_INFO.namespace}"
      xmlns:ogc="http://www.opengis.net/ogc">
      ${TransactionFragments}
    </wfs:Transaction>
  `
  console.log('WFS-T Transaction请求XML:', wfsTransaction)
  try {
    const response = await axios.post(url, wfsTransaction, {
      headers: {
        'Content-Type': 'text/xml', // 必须设置Content-Type为text/xml
        Accept: 'application/xml', // 响应数据类型为XML
      },
    })

    console.log(`WFS-T${operation}响应:`, response.data)
    return response.data
  } catch (error) {
    console.error('保存要素失败:', error)
  }
```

# 拓展功能
## 暗黑模式
**利用 Element Plus 暗黑主题**：Element Plus 提供了内置的暗黑模式样式，通过全局类名`dark`触发；

**状态管理**：用 Pinia 存储暗黑模式状态，确保全局共享；

**本地存储**：将用户偏好保存到`localStorage`，刷新页面后保持状态；

**样式适配**：自定义暗黑模式下的全局样式和组件样式，与 Element Plus 风格统一

<font style="color:rgb(0, 0, 0);"></font>

**<font style="color:#01B2BC;">安装依赖（若未安装）</font>**

确保已安装 Element Plus 和 Pinia：

```bash
npm install element-plus @element-plus/icons-vue pinia
```

**<font style="color:#01B2BC;">配置 Element Plus 暗黑模式</font>**

在入口文件（`main.ts`）中引入 Element Plus 的暗黑主题样式，并配置全局变量：

```javascript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
// 引入Element Plus暗黑主题变量
import 'element-plus/theme-chalk/dark/css-vars.css'
// 导入全局样式（含暗黑模式适配）
import '@/assets/styles/dark-mode.less'

import App from './App.vue'
import router from './router'

// 无需全局注册ElementPlus组件（按需导入插件会自动处理）
const app = createApp(App)

app.use(createPinia())
app.use(router)
app.mount('#app')
```

<font style="color:rgb(0, 0, 0);">创建主题状态管理（Pinia）</font>

新建`stores/modules/themeStore.ts`，管理暗黑模式状态：

```javascript
import { defineStore } from 'pinia' // 定义一个pinia的store
import { ref, onMounted } from 'vue'

export const useThemeStore = defineStore('theme', () => {
  // 状态：使用ref定义响应式变量
  const isDark = ref(localStorage.getItem('isDark') === 'true' || false)

  // 方法：切换暗黑模式
  const toggleDarkMode = () => {
    isDark.value = !isDark.value
    // 保存到本地存储
    localStorage.setItem('isDark', String(isDark.value))
    // 更新HTML类名
    updateHtmlClass()
  }

  // 方法：更新根元素类名
  const updateHtmlClass = () => {
    const html = document.documentElement
    if (isDark.value) {
      html.classList.add('dark')
    } else {
      html.classList.remove('dark')
    }
  }

  // 初始化：页面加载时同步状态（替代原created钩子）
  onMounted(() => {
    updateHtmlClass()
  })

  // 暴露状态和方法
  return {
    isDark,
    toggleDarkMode,
    updateHtmlClass
  }
})
```

`stores/index.ts`

```javascript
import { createPinia } from 'pinia' // 创建pinia
import persist from 'pinia-plugin-persistedstate' // pinia数据持久化
const pinia = createPinia() // 创建pinia实例
pinia.use(persist) // 使用持久化插件
export default pinia // 导出pinia实例
// 导出所有的store
export * from './modules/user'
export * from './modules/counter'
export * from './modules/theme'
```

**<font style="color:#01B2BC;">实现主题切换组件</font>**

创建`components/ThemeToggle.vue`，用于切换暗黑 / 亮色模式：

主题切换组件

```vue
<script setup>
  import { useThemeStore } from '@/stores/index'
  // 按需导入图标（或通过unplugin-icons自动导入）
  import { Moon, Sunny } from '@element-plus/icons-vue'
  import { storeToRefs } from 'pinia'

  const themeStore = useThemeStore()
  const { isDark } = storeToRefs(themeStore)

  const toggleTheme = () => {
    themeStore.toggleDarkMode()
  }
</script>
<template>
  <el-button
    circle
    size="small"
    :class="isDark ? 'dark-mode-btn' : 'light-mode-btn'"
    @click="toggleTheme"
    :title="isDark ? '切换至亮色模式' : '切换至暗黑模式'"
    >
    <el-icon :size="18">
      <sunny v-if="isDark" />
      <moon v-else />
    </el-icon>
  </el-button>
</template>

<style scoped lang="less">
  .light-mode-btn {
    background: #f5f5f5;
    color: #333;
    &:hover {
      background: #e5e5e5;
    }
  }

  .dark-mode-btn {
    background: #1f2329;
    color: #fff;
    &:hover {
      background: #303640;
    }
  }
</style>

```

**<font style="color:#01B2BC;">在布局中集成切换按钮</font>**

在之前设计的`MainLayout.vue`头部导航中添加切换按钮（位置：右上角退出登录按钮左侧）：

集成切换按钮的布局

```html
<template>
  <header class="header">
    <!-- logo -->
    <div class="header-logo">
      <img src="../assets/logo.png" alt="" />
      <span class="logo-text">市政消防栓管理系统</span>
      <span class="logo-version">0.0.1</span>
    </div>
    <!-- 菜单栏 -->
    <div class="header-nav">
      <el-menu mode="horizontal" :default-active="activeMenu" router>
        <el-menu-item index="/map">首页</el-menu-item>
        <el-menu-item index="/user">用户中心</el-menu-item>
        <!-- 主题开关（示例：控制深色模式，需结合业务逻辑） -->
        <div class="header-actions">
          <theme-toggle></theme-toggle>
        </div>
      </el-menu>
    </div>
  </header>
</template>
```

**<font style="color:#01B2BC;">自定义暗黑模式样式</font>**

创建全局样式文件`src/assets/styles/dark-mode.less`，适配非 Element 组件的暗黑模式样式：

暗黑模式自定义样式

```javascript
html.dark {
  .el-menu--horizontal.el-menu {
    border-bottom: none !important;
  }
}
```

**<font style="color:#01B2BC;">在</font>**`**<font style="color:#01B2BC;">main.js</font>**`**<font style="color:#01B2BC;">中引入全局样式：</font>**

```javascript
// main.js 新增
import '@/assets/styles/dark-mode.less'
```

**实现原理说明**

Element Plus 暗黑模式触发：

+ Element Plus 的暗黑主题通过根元素的`dark`类名激活
+ 引入的`dark/css-vars.css`中定义了相关样式，切换类名即可切换主题

状态持久化：

+ 用`localStorage`保存用户选择的模式，页面初始化时从本地读取状态，确保刷新后保持一致

样式过渡：

+ 对背景色、边框色等添加`transition`动画，实现切换时的平滑过渡效果

自定义样式适配：

+ 针对非 Element 组件（如自定义卡片、地图容器）
+ 通过`html.dark`选择器定义暗黑模式下的样式，确保整体风格统一

**扩展优化建议**

跟随系统主题：

+ 可添加 “跟随系统” 选项，
+ 通过`window.matchMedia('(prefers-color-scheme: dark)').matches`检测系统主题

主题色定制：

+ 如需修改 Element Plus 暗黑模式的默认颜色，可覆盖 CSS 变量（在`dark-mode.less`中）

```less
html.dark {
  --el-color-primary: #4096ff; // 自定义主色调
  --el-bg-color: #121212; // 自定义背景色
}
```

**组件级样式适配**：

+ 对复杂组件，可在组件内通过`::v-deep`穿透作用域，针对性调整暗黑模式样式：****

```vue
<style scoped lang="less">
::v-deep .custom-component {
  background: #fff;
}
html.dark ::v-deep .custom-component {
  background: #1e1e1e;
}
</style>
```

